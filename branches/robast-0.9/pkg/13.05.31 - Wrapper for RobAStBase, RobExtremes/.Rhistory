,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = col.abline
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=75, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
##########################################
##                                      ##
##    Wrapper for outlyingnessPlot.R    ##
##                                      ##
##                                      ##
##########################################
##projection distance
qfun = function(x){p0 = p(X)(x); q0 = q(X)(p0)}
QProj <- function(){new("NormType", name="Quantiles", fct=qfun)}
##@x - dataset
##@X - random variable
##@fam - parameter family
##@alpha - confidence level for quantile
#
plotOutlyingness = function(x,alpha=0.99,fam=GParetoFamily(),...,alpha.trsp = 100, with.legend = TRUE){
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(dots$alpha.trsp)) dots$alpha.trsp <- 100
if(is.null(dots$with.legend)) dots$with.legend <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'plotOutlyingness'")
if(missing(alpha)) stop("Argument 'alpha' must be given as argument to 'plotOutlyingness'")
if(missing(fam)) stop("Argument 'fam' must be given as argument to 'plotOutlyingness'")
##logarithmic representation (for distributions with positive support)
fam@distribution = log(fam@distribution)
##classical IC
ICmle <- optIC(model=fam,risk=asCov())
##parameter for plotting
if(with.legend)
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "black", col.lab = "black")
col.Abline = rgb(52,52,52,maxColorValue=255)}
else
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "white", col.lab = "white")
colAbline = "white"}
cutoff.quantile.x = alpha
cutoff.quantile.y = alpha
##call of routine from RobAStBase
outlyingPlotIC(x
,IC.x = ICmle
,IC.y = ICmle
,dist.x = QProj()
#NormType() - Euclidean norm, default - Mahalanobis norm
#,dist.y = NormType()
,adj = 0.1
,pch = 21
,col.idn = rgb(102,102,102,maxColorValue=255)
,cex.idn = 1.7
,col.cutoff = rgb(202,202,202,maxColorValue=255)
,offset = 0
,cutoff.quantile.x = cutoff.quantile.x
,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = colAbline
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=75, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
##########################################
##                                      ##
##    Wrapper for outlyingnessPlot.R    ##
##                                      ##
##                                      ##
##########################################
##projection distance
qfun = function(x){p0 = p(X)(x); q0 = q(X)(p0)}
QProj <- function(){new("NormType", name="Quantiles", fct=qfun)}
##@x - dataset
##@X - random variable
##@fam - parameter family
##@alpha - confidence level for quantile
#
plotOutlyingness = function(x,alpha=0.99,fam=GParetoFamily(),...,alpha.trsp = 100, with.legend = TRUE){
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(dots$alpha.trsp)) dots$alpha.trsp <- 100
if(is.null(dots$with.legend)) dots$with.legend <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'plotOutlyingness'")
if(missing(alpha)) stop("Argument 'alpha' must be given as argument to 'plotOutlyingness'")
if(missing(fam)) stop("Argument 'fam' must be given as argument to 'plotOutlyingness'")
##logarithmic representation (for distributions with positive support)
fam@distribution = log(fam@distribution)
##classical IC
ICmle <- optIC(model=fam,risk=asCov())
##parameter for plotting
if(with.legend)
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "black", col.lab = "black")
col.Abline = rgb(52,52,52,maxColorValue=255)}
else
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "white", col.lab = "white")
colAbline = "white"}
print(colAbline)
cutoff.quantile.x = alpha
cutoff.quantile.y = alpha
##call of routine from RobAStBase
outlyingPlotIC(x
,IC.x = ICmle
,IC.y = ICmle
,dist.x = QProj()
#NormType() - Euclidean norm, default - Mahalanobis norm
#,dist.y = NormType()
,adj = 0.1
,pch = 21
,col.idn = rgb(102,102,102,maxColorValue=255)
,cex.idn = 1.7
,col.cutoff = rgb(202,202,202,maxColorValue=255)
,offset = 0
,cutoff.quantile.x = cutoff.quantile.x
,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = colAbline
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=75, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
##########################################
##                                      ##
##    Wrapper for outlyingnessPlot.R    ##
##                                      ##
##                                      ##
##########################################
##projection distance
qfun = function(x){p0 = p(X)(x); q0 = q(X)(p0)}
QProj <- function(){new("NormType", name="Quantiles", fct=qfun)}
##@x - dataset
##@X - random variable
##@fam - parameter family
##@alpha - confidence level for quantile
#
plotOutlyingness = function(x,alpha=0.99,fam=GParetoFamily(),...,alpha.trsp = 100, with.legend = TRUE){
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(dots$alpha.trsp)) dots$alpha.trsp <- 100
if(is.null(dots$with.legend)) dots$with.legend <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'plotOutlyingness'")
if(missing(alpha)) stop("Argument 'alpha' must be given as argument to 'plotOutlyingness'")
if(missing(fam)) stop("Argument 'fam' must be given as argument to 'plotOutlyingness'")
##logarithmic representation (for distributions with positive support)
fam@distribution = log(fam@distribution)
##classical IC
ICmle <- optIC(model=fam,risk=asCov())
##parameter for plotting
if(with.legend)
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "black", col.lab = "black")}
else
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "white", col.lab = "white")}
cutoff.quantile.x = alpha
cutoff.quantile.y = alpha
##call of routine from RobAStBase
outlyingPlotIC(x
,IC.x = ICmle
,IC.y = ICmle
,dist.x = QProj()
#NormType() - Euclidean norm, default - Mahalanobis norm
#,dist.y = NormType()
,adj = 0.1
,pch = 21
,col.idn = rgb(102,102,102,maxColorValue=255)
,cex.idn = 1.7
,col.cutoff = rgb(202,202,202,maxColorValue=255)
,offset = 0
,cutoff.quantile.x = cutoff.quantile.x
,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = rgb(52,52,52,maxColorValue=255)
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=75, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
##########################################
##                                      ##
##    Wrapper for outlyingnessPlot.R    ##
##                                      ##
##                                      ##
##########################################
##projection distance
qfun = function(x){p0 = p(X)(x); q0 = q(X)(p0)}
QProj <- function(){new("NormType", name="Quantiles", fct=qfun)}
##@x - dataset
##@X - random variable
##@fam - parameter family
##@alpha - confidence level for quantile
#
plotOutlyingness = function(x,alpha=0.99,fam=GParetoFamily(),...,alpha.trsp = 100, with.legend = TRUE){
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(dots$alpha.trsp)) dots$alpha.trsp <- 100
if(is.null(dots$with.legend)) dots$with.legend <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'plotOutlyingness'")
if(missing(alpha)) stop("Argument 'alpha' must be given as argument to 'plotOutlyingness'")
if(missing(fam)) stop("Argument 'fam' must be given as argument to 'plotOutlyingness'")
##logarithmic representation (for distributions with positive support)
fam@distribution = log(fam@distribution)
##classical IC
ICmle <- optIC(model=fam,risk=asCov())
##parameter for plotting
if(with.legend)
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "black", col.lab = "black")}
else
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "white", col.lab = "white")}
cutoff.quantile.x = alpha
cutoff.quantile.y = alpha
##call of routine from RobAStBase
outlyingPlotIC(x
,IC.x = ICmle
,IC.y = ICmle
,dist.x = QProj()
#NormType() - Euclidean norm, default - Mahalanobis norm
#,dist.y = NormType()
,adj = 0.1
,pch = 21
,col.idn = rgb(102,102,102,maxColorValue=255)
,cex.idn = 1.7
,col.cutoff = rgb(202,202,202,maxColorValue=255)
,offset = 0
,cutoff.quantile.x = cutoff.quantile.x
,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = rgb(52,52,52,maxColorValue=255)
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=50, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
myplot <- function(x,y, ..., withCall =TRUE){
###
### 1. grab the dots (and probably manipulate it within the wrapper function)
###
dots <- as.list(match.call(expand.dots=FALSE))$"..."
###
## do something to fix the good default arguments
###
### 2. build up the argument list for the (powerful/fullfledged)
### graphics/diagnostics function;
### mind not to evaluate the x and (possibly) y args to provide automatic
### axis annotation
###
args <- c(list(x=substitute(x),y=substitute(y)),dots, type="l")
###
### 3. build up the call but grab it and write it into an object
###
cl <- substitute(do.call(plot,args0), list(args0=args))
### manipulate it so that the wrapper do.call is ommitted
cl0 <- as.list(cl)[-1]
mycall <- c(cl0,unlist(cl0[-1]))
mycall <- as.call(mycall)
###
### 4. evaluate the call (i.e., produce the graphic)
###
eval(mycall)
###
### 5. return the call (if withCall==TRUE)
###
if(withCall) return(mycall) else return(invisible(NULL))
}
x <- 1:20
y <- rnorm(20)
cl <- myplot(x,y,col="red")
eval(cl)
cl <- myplot(x,y)
args <- c(list(x=substitute(x),y=substitute(y)),dots, type="l")
dots <- as.list(match.call(expand.dots=FALSE))$"..."
cl <- substitute(do.call(plot,args0), list(args0=args))
cl0 <- as.list(cl)[-1]
mycall <- c(cl0,unlist(cl0[-1]))
mycall <- as.call(mycall)
###
### 4. evaluate the call (i.e., produce the graphic)
###
eval(mycall)
###
### 5. return the call (if withCall==TRUE)
###
if(withCall) return(mycall) else return(invisible(NULL))
##########################################
##                                      ##
##    Wrapper for outlyingnessPlot.R    ##
##                                      ##
##                                      ##
##########################################
##projection distance
qfun = function(x){p0 = p(X)(x); q0 = q(X)(p0)}
QProj <- function(){new("NormType", name="Quantiles", fct=qfun)}
##@x - dataset
##@X - random variable
##@fam - parameter family
##@alpha - confidence level for quantile
#
plotOutlyingness = function(x,alpha=0.99,fam=GParetoFamily(),...,alpha.trsp = 100, with.legend = TRUE){
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(dots$alpha.trsp)) dots$alpha.trsp <- 100
if(is.null(dots$with.legend)) dots$with.legend <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'plotOutlyingness'")
if(missing(alpha)) stop("Argument 'alpha' must be given as argument to 'plotOutlyingness'")
if(missing(fam)) stop("Argument 'fam' must be given as argument to 'plotOutlyingness'")
args <- c(list(x=substitute(x),alpha=substitute(alpha),fam=substitute(fam)),dots, type="l")
cl <- substitute(do.call(plot,args0), list(args0=args))
### manipulate it so that the wrapper do.call is ommitted
cl0 <- as.list(cl)[-1]
mycall <- c(cl0,unlist(cl0[-1]))
mycall <- as.call(mycall)
###
### 4. evaluate the call (i.e., produce the graphic)
###
eval(mycall)
##logarithmic representation (for distributions with positive support)
fam@distribution = log(fam@distribution)
##classical IC
ICmle <- optIC(model=fam,risk=asCov())
##parameter for plotting
if(with.legend)
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "black", col.lab = "black")}
else
{par(cex=1,bty="n", col = addAlphTrsp2col(rgb(102,102,102,maxColorValue=255), alpha.trsp),
col.main = "white", col.lab = "white")}
cutoff.quantile.x = alpha
cutoff.quantile.y = alpha
##call of routine from RobAStBase
outlyingPlotIC(x
,IC.x = ICmle
,IC.y = ICmle
,dist.x = QProj()
#NormType() - Euclidean norm, default - Mahalanobis norm
#,dist.y = NormType()
,adj = 0.1
,pch = 21
,col.idn = rgb(102,102,102,maxColorValue=255)
,cex.idn = 1.7
,col.cutoff = rgb(202,202,202,maxColorValue=255)
,offset = 0
,cutoff.quantile.x = cutoff.quantile.x
,cutoff.quantile.y = cutoff.quantile.y
,cutoff.x = cutoff()
,cutoff.y = cutoff.sememp()
,robCov.x = TRUE
,robCov.y = TRUE
,tf.x = function(x)log(x)
,cex.main = 1.5
,cex.lab = 1.5
,cex = 1.5
#,col.lab=FhGred
,lwd.cutoff = 3
#,jitt.fac = 300
,col.abline = rgb(52,52,52,maxColorValue=255)
,cex.abline = 1.2
,adj.abline = c(0.8, 0.2)
,main = ""#"Outlyingness Plot"
,xlab="Theoretical log-quantiles"
,ylab="Mahalanobis distance"
)
}
##Example
require(RobExtremes)
X = GPareto()
fam = GParetoFamily()
x = r(X)(1000)
plotOutlyingness(x,alpha=0.95,fam=fam,alpha.trsp=50, with.legend = TRUE)
plotOutlyingness(x,alpha=0.99,fam=fam, with.legend = FALSE)
myplot <- function(x,y, ..., withCall = TRUE){
###
### 1. grab the dots (and probably manipulate it within the wrapper function)
###
mc <- as.list(match.call(expand.dots = FALSE))[-1]
dots <- mc$"..."
if(is.null(mc$withCall)) mc$withCall <- TRUE
if(missing(x)) stop("Argument 'x' must be given as argument to 'myplot'")
if(missing(y)) stop("Argument 'y' must be given as argument to 'myplot'")
###
## do something to fix the good default arguments
###
### 2. build up the argument list for the (powerful/fullfledged)
### graphics/diagnostics function;
### mind not to evaluate the x and (possibly) y args to provide automatic
### axis annotation
###
args <- c(list(x=substitute(x),y=substitute(y)),dots,type="l")
###
### 3. build up the call but grab it and write it into an object
###
cl <- substitute(do.call(plot,args0), list(args0=args))
### manipulate it so that the wrapper do.call is ommitted
cl0 <- as.list(cl)[-1]
mycall <- c(cl0[1],unlist(cl0[-1]))
mycall <- as.call(mycall)
###
### 4. evaluate the call (i.e., produce the graphic)
###
eval(mycall)
###
### 5. return the call (if withCall==TRUE)
###
if(mc$withCall) print(mycall)
}
x <- 1:20
y <- rnorm(20)
cl <- myplot(x,y,col="red", withCall=TRUE)
cl <- myplot(x,y,col="blue")
cl <- myplot(x,y,col="green", withCall=FALSE)
