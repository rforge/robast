---------------------------------------------------------------------------
Nachteil: Produkt-Design
---------------------------------------------------------------------------
Meines Erachtens ist die volle Nutzung vom Method dispatch im
"kartesischen Produkt"-Modell nicht erforderlich
(d.h. dispatch auf dem Tripel x, IC, start),
weil das eine nicht notwendige Vielzahl extrem ähnlicher
Methoden nach sich zieht  --- genauer

 $\#\mbox{Klassen für x} \times #\mbox{Klassen für IC}
     \times #\mbox{Klassen für start}$

 Zahl an Methoden ---

Das hast Du ja bisher konsequent (und fehlerfrei!) so gemacht,
diese Redundanz stellt sich aber nun in der Maintenance als nachteilig heraus:
Modifikationen müssten in gleicher Form für alle Methoden gemacht werden.

Zwei Auswegstrategien:

(a) immer noch viele Methoden, aber ähnliche Methoden rufen immer
mit getMethod(signature="") eine Referenz-Methode auf

(b) wir machen aus der Methode kStepEstimator doch wieder eine
gewöhnliche Funktion, rufen aber in ihr Methoden auf, die einen Dispatch
jeweils nach nur einem Original-Argument machen ---
das logarithmiert die Zahl der benötigten Methoden (oder macht aus dem
Produkt eine Summe); funktioniert aber natürlich nur dann, wenn der Dispatch
nach den einzelnen Argumenten unabhängig (im Sinn wie in stochastischer
Unabhängigkeit (!)) gemacht werden können.

Diesen Designpunkt sollten wir auf jeden Fall auch in unserem Artikel
encaps aufnehmen.

Mein Vorschlag ist (b) --- siehe auch kStepEstimator() in oneKstepEstimator.R
den Code will ich aber noch genauer checken.

---------------------------------------------------------------------------
voller Parameter bei k-Schritt-Schätzer
---------------------------------------------------------------------------
Hier tut sich nun noch beim k-Schritt-Schätzer ein weiteres Problem auf:
Was machen wir genau mit partiellen ICs bei "Bewegungen des Modells" ;
dafür brauchen wir ja eine Schätzung für das volle $\theta$ ---
auch hier zwei Strategien:

Zunächst sollte in beiden Strategien ein ("sehr") robuster Start-Schätzer
$\theta_0$ für das volle $\theta$ berechnet werden; dann

(1) Gegeben $D=D_\theta=\partial/\partial t \tau (t)|_{t=\theta}$
      und die robust optimale pIC $\eta=\eta_\theta$
      berechne "nur" die weitere pIC $\chi=D^- \eta$,
      $D^-$ generalisierte Inverse von $D$
      und datiere theta auf durch
      $\theta_{i+1}=\theta_i + {\rm mean}(\chi(X_i))$
      --- das würde die Projektion von $\theta_0$ im Orthogonalraum
     zum Spaltenraum von $D$ in der Iteration invariant lassen, da
      $$(\EM_p-D^-D) \theta_{i+1}=
      =(\EM_p-D^-D) \theta_{i} + {\rm mean}(\chi(X_i)) - D^-D{\rm mean}(\chi(X_i))
      =(\EM_p-D^-D) \theta_{i} + {\rm mean}(D^-\eta (X_i)) - {\rm mean}(D^-D D^-\eta (X_i))
      =(\EM_p-D^-D) \theta_{i} + {\rm mean}(D^-\eta (X_i)) - {\rm mean}(D^-\eta (X_i))
      =(\EM_p-D^-D) \theta_{i} = \ldots = (\EM_p-D^-D) \theta_{0}
      $$
     Wollen wir das ? --- vom Konzept "Nuisance" her sollte uns das Verhalten
     unseres Schätzers auf $(\EM_p-D^-D)$ egal sein ...

(2)  --- eher im Sinn von Ri:94, 4.2.11(e):
     Ergänze $\chi$ per Addition auf eine echte IC ---
     dh. nehme eine irgendwie geartete beschränkte IC (D=\EM)
     $\psi$ und produziere
     $\tilde \chi=\chi + (\EM_p-D^-D) \psi$
     und datiere auf mit
      $\theta_{i+1}=\theta_i + {\rm mean}(\tilde\chi(X_i))$
    hier wird also der Schätzer für $\theta$ auch auf  $(\EM_p-D^-D)$ weiter
    verbessert, es gilt aber $D\tilde \chi=D\chi=\eta$.

Mir erscheint (2) bei nichtlinearem $\tau$ vertrauenserweckender,
obwohl das nicht ganz klar ist ....


Ich habe mal die Zusatzfunktionen für (2) in
oneKstepEstimator.R geschrieben --- auch hier ist noch checking
erforderlich!

* getBoundedIC()   für die Gewinnung von $\psi$
in (2) --- kannst Du da mal drüberschauen; Du kennst Deine RandVar-Klassen
besser als ich; geclippt wird auf Höhe $b=\tr {\cal I}^-$ und macht dann einen
Schritt in Ri:94 5.5.2 ...

* Die Umsetzung von Strategie zwei erfolgt in Funktion updateStep(),
Zeilen 102-120
(newIC.tot1 ^= \chi, newIC.tot2 ^= (\EM_p-D^-D) \psi)
mit Aufdatierungs-Schritt in  116-117

Eine if-Abfrage zur Entscheidung (1) oder (2) ist natürlich kein Problem...

-----------------------------------------------------------------
lokale update Funktion
-----------------------------------------------------------------
updateStep() , Zeile 91 in oneKstepEstimator.R, wird
in Funktion kStepEstimator() ja mehrfach benutzt; daher sollte
eine Funktion hilfreich sein, um Redundanz zu vemeiden ---
was denkst Du?
-----------------------------------------------------------------
oneStepEstimator
-----------------------------------------------------------------
kann doch eigentlich noch viel stärker kStepEstimator nutzen....
vgl oneStepEstimator() in oneKstepEstimator.R --- was denkst Du?
-----------------------------------------------------------------
roptest
-----------------------------------------------------------------
Hier ist mir aufgefallen, dass Du bisher die Methode mit Argument
start als "Estimate" nie nutzt; daher die Einführung von init.est in Zeile 295
in oneKstepEstimator.R