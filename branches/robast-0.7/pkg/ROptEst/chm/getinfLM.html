<html><head><title>Functions to determine Lagrange multipliers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head><body>

<table width="100%"><tr><td>getInfLM(ROptEst)</td><td align="right">R Documentation</td></tr></table>
<object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   getInfLM">
<param name="keyword" value="R:   getLagrangeMultByOptim">
<param name="keyword" value="R:   getLagrangeMultByIter">
<param name="keyword" value=" Functions to determine Lagrange multipliers">
</object>


<h2>Functions to determine Lagrange multipliers</h2>


<h3>Description</h3>

<p>
Functions to determine Lagrange multipliers <code>A</code> and <code>a</code>
in a Hampel problem or in a(n) (inner) loop in a MSE problem; can be done
either by optimization or by fixed point iteration. These functions are
rarely called directly.
</p>


<h3>Usage</h3>

<pre>
getLagrangeMultByIter(b, L2deriv, risk, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start, std, z.comp,
                      A.comp, maxiter, tol,
                      verbose = getRobAStBaseOption("all.verbose"),
                      warnit = TRUE)
getLagrangeMultByOptim(b, L2deriv, risk, FI, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start,  std, z.comp,
                      A.comp, maxiter, tol,
                      verbose = getRobAStBaseOption("all.verbose"), ...)

</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>b</code></td>
<td>
numeric; (<i>&gt;b_min</i>; clipping bound
for which the Lagrange multipliers are searched</td></tr>
<tr valign="top"><td><code>L2deriv</code></td>
<td>
 L2-derivative of some L2-differentiable family
of probability measures. </td></tr>
<tr valign="top"><td><code>risk</code></td>
<td>
 object of class <code>"RiskType"</code>. </td></tr>
<tr valign="top"><td><code>FI</code></td>
<td>
 matrix: Fisher information. </td></tr>
<tr valign="top"><td><code>trafo</code></td>
<td>
 matrix: transformation of the parameter. </td></tr>
<tr valign="top"><td><code>neighbor</code></td>
<td>
 object of class <code>"Neighborhood"</code>. </td></tr>
<tr valign="top"><td><code>biastype</code></td>
<td>
object of class <code>"BiasType"</code> &mdash; the bias type with we work.</td></tr>
<tr valign="top"><td><code>normtype</code></td>
<td>
object of class <code>"NormType"</code> &mdash; the norm type with we work.</td></tr>
<tr valign="top"><td><code>Distr</code></td>
<td>
 object of class <code>"Distribution"</code>. </td></tr>
<tr valign="top"><td><code>a.start</code></td>
<td>
 initial value for the centering constant (in <code>p</code>-space). </td></tr>
<tr valign="top"><td><code>z.start</code></td>
<td>
 initial value for the centering constant (in <code>k</code>-space). </td></tr>
<tr valign="top"><td><code>A.start</code></td>
<td>
 initial value for the standardizing matrix. </td></tr>
<tr valign="top"><td><code>w.start</code></td>
<td>
 initial value for the weight function. </td></tr>
<tr valign="top"><td><code>std</code></td>
<td>
 matrix of (or which may coerced to) class
<code>PosSemDefSymmMatrix</code> for use of different
(standardizing) norm. </td></tr>
<tr valign="top"><td><code>z.comp</code></td>
<td>
 logical vector: indication which components of the
centering constant have to be computed. </td></tr>
<tr valign="top"><td><code>A.comp</code></td>
<td>
 matrix: indication which components of the standardizing
matrix have to be computed. </td></tr>
<tr valign="top"><td><code>maxiter</code></td>
<td>
 the maximum number of iterations. </td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
 the desired accuracy (convergence tolerance).</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
 logical: if <code>TRUE</code>, some messages are printed. </td></tr>
<tr valign="top"><td><code>warnit</code></td>
<td>
 logical: if <code>TRUE</code> warning is issued if
maximal number of iterations is reached. </td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
 additional parameters for <code>optim</code>. </td></tr>
</table>


<h3>Value</h3>

<p>a list with items
<table summary="R valueblock">
<tr valign="top"><td><code>A</code></td>
<td>
Lagrange multiplier <code>A</code> (standardizing matrix)</td></tr>
<tr valign="top"><td><code>a</code></td>
<td>
Lagrange multiplier <code>a</code> (centering in <code>p</code>-space)</td></tr>
<tr valign="top"><td><code>z</code></td>
<td>
Lagrange multiplier <code>z</code> (centering in <code>k</code>-space)</td></tr>
<tr valign="top"><td><code>w</code></td>
<td>
weight function involving Lagrange multipliers</td></tr>
<tr valign="top"><td><code>biastype</code></td>
<td>
(possibly modified) bias type <code>biastype</code> from argument</td></tr>
<tr valign="top"><td><code>normtype</code></td>
<td>
(possibly modified) norm type <code>normtype</code> from argument</td></tr>
<tr valign="top"><td><code>normtype.old</code></td>
<td>
(possibly modified) norm type <code>normtype</code>
before last (internal) update</td></tr>
<tr valign="top"><td><code>risk</code></td>
<td>
(possibly [norm-]modified) risk <code>risk</code> from argument</td></tr>
<tr valign="top"><td><code>std</code></td>
<td>
(possibly modified) argument <code>std</code></td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
number of iterations needed</td></tr>
<tr valign="top"><td><code>prec</code></td>
<td>
precision achieved</td></tr>
<tr valign="top"><td><code>b</code></td>
<td>
used clippng height <code>b</code></td></tr>
<tr valign="top"><td><code>call</code></td>
<td>
call with which either <code>getLagrangeMultByIter</code> or
<code>getLagrangeMultByOptim</code> was called </td></tr>
</table>
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@itwm.fraunhofer.de">Peter.Ruckdeschel@itwm.fraunhofer.de</a></p>


<h3>References</h3>

<p>
Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <B>8</B>: 106-115.
</p>
<p>
Rieder, H. (1994) <EM>Robust Asymptotic Statistics</EM>. New York: Springer.
</p>
<p>
Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <B>22</B>: 201-223.
</p>
<p>
Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <EM>14</EM>(1), 105-131.
</p>
<p>
Kohl, M. (2005) <EM>Numerical Contributions to the Asymptotic Theory of Robustness</EM>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a onclick="findlink('RobAStBase', 'InfRobModel-class.html')" style="text-decoration: underline; color: blue; cursor: hand">InfRobModel-class</a></code></p>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>

<hr><div align="center">[Package <em>ROptEst</em> version 0.7 <a href="00Index.html">Index</a>]</div>
</body></html>
