## new helper function for make and check IC to speed up things

.preparedirectCheckMakeIC <- function(L2Fam, IC, ...){

        dims <- length(L2Fam@param)
        trafo <- trafo(L2Fam@param)
        nrvalues <- nrow(trafo)
        Distr <- L2Fam@distribution

        dotsI <- .filterEargs(list(...))
        if(is.null(dotsI$useApply)) dotsI$useApply <- FALSE


        IC.v <- as(diag(nrvalues) %*% IC@Curve, "EuclRandVariable")
        L2deriv <- as(diag(dims) %*% L2Fam@L2deriv, "EuclRandVariable")

        res <- numeric(nrvalues)
        for(i in 1:nrvalues){
            Eargs <- c(list(object = Distr, fun = IC.v@Map[[i]]), dotsI)
            res[i] <- do.call(E, Eargs)
        }

        integrandA <- function(x, IC.i, L2.j){
            return(IC.i(x)*L2.j(x))
        }

        erg <- matrix(0, ncol = dims, nrow = nrvalues)

        for(i in 1:nrvalues)
            for(j in 1:dims){
                  Eargs <- c(list(object = Distr, fun = integrandA,
                                  IC.i = IC.v@Map[[i]], L2.j = L2deriv@Map[[j]]),
                                  dotsI)
                  erg[i, j] <- do.call(E, Eargs)
            }

        return(list(E.IC=res,E.IC.L=erg))
}



## check centering and Fisher consistency
setMethod("checkIC", signature(IC = "IC", L2Fam = "missing"),
    function(IC, out = TRUE, ...){
        L2Fam <- eval(IC@CallL2Fam)
        getMethod("checkIC", signature(IC = "IC", L2Fam = "L2ParamFamily"))(
              IC = IC, L2Fam = L2Fam, out = out, ...)
    })

## check centering and Fisher consistency
setMethod("checkIC", signature(IC = "IC", L2Fam = "L2ParamFamily"),
    function(IC, L2Fam, out = TRUE, ...){
        D1 <- L2Fam@distribution
        if(dimension(Domain(IC@Curve[[1]])) != dimension(img(D1)))
            stop("dimension of 'Domain' of 'Curve' != dimension of 'img' of 'distribution' of 'L2Fam'")

        trafo <- trafo(L2Fam@param)

        res <- .preparedirectCheckMakeIC(L2Fam, IC, ...)

        cent <- res$E.IC
        if(out)
            cat("precision of centering:\t", cent, "\n")


        consist <- res$E.IC.L - trafo

        if(out){
            cat("precision of Fisher consistency:\n")
            print(consist)
            cat("precision of Fisher consistency - relative error [%]:\n")
            print(100*consist/trafo)
        }

        prec <- max(abs(cent), abs(consist))
        names(prec) <- "maximum deviation"

        return(prec)
    })


## make some L2function a pIC at a model
setMethod("makeIC", signature(IC = "IC", L2Fam = "L2ParamFamily"),
    function(IC, L2Fam, ...){

        dims <- length(L2Fam@param)
        if(dimension(IC@Curve) != dims)
           stop("Dimension of IC and parameter must be equal")

        D1 <- L2Fam@distribution
        if(dimension(Domain(IC@Curve[[1]])) != dimension(img(D1)))
            stop("dimension of 'Domain' of 'Curve' != dimension of 'img' of 'distribution' of 'L2Fam'")

        trafo <- trafo(L2Fam@param)

        res <- .preparedirectCheckMakeIC(L2Fam, IC, ...)

        IC1 <- as(diag(dimension(IC@Curve)) %*% IC@Curve, "EuclRandVariable")

        cent <- res$E.IC
        stand <- trafo %*% distr::solve(res$E.IC.L, generalized = TRUE)

        Y <- as(stand %*% (IC1 - cent), "EuclRandVariable")

        modifyIC <- IC@modifyIC

        if(!is.function(IC@modifyIC))
            modifyIC <- function(L2Fam, IC, withMakeIC = FALSE, ...)
                                 return(makeIC(IC,L2Fam, ...))

        CallL2Fam <- L2Fam@fam.call

        return(IC(name = name(IC),
                  Curve = EuclRandVarList(Y),
                  Risks = list(),
                  Infos=matrix(c("IC<-",
                                 "generated by affine linear trafo to enforce consistency"),
                               ncol=2, dimnames=list(character(0), c("method", "message"))),
                  CallL2Fam = CallL2Fam,
                  modifyIC = modifyIC))
    })

## make some L2function a pIC at a model
setMethod("makeIC", signature(IC = "IC", L2Fam = "missing"),
    function(IC, ...){
        L2Fam0 <- eval(IC@CallL2Fam)
        getMethod("makeIC", signature(IC = "IC", L2Fam = "L2ParamFamily"))(
              IC = IC, L2Fam = L2Fam, ...)
    })

setMethod("makeIC", signature(IC = "list", L2Fam = "L2ParamFamily"),
    function(IC, L2Fam, forceIC = TRUE, name, Risks, Infos, modifyIC = NULL,...){
        mc <- match.call(call = sys.call(sys.parent(1)), expand.dots = FALSE)[-1]
        mc0 <- as.list(mc)
        mc0$IC <- NULL
        mc0$L2Fam <- NULL
        mc0$forceIC <- NULL
        if(!all(as.logical(c(lapply(IC,is.function)))))
           stop("First argument must be a list of functions")

        IC.1 <- lapply(IC, function(IC.2)
                  if(length(formals(IC.2))==0) function(x) IC.2(x) else IC.2)

        mc0$Curve <- EuclRandVarList(RealRandVariable(Map = IC.1, Domain = Reals()))
        mc0$CallL2Fam <- substitute(L2Fam@fam.call)

        IC.0 <- do.call(.IC,mc0)
        if(forceIC) IC.0 <- makeIC(IC.0, L2Fam,...)
        return(IC.0)
    })



setMethod("makeIC", signature(IC = "function", L2Fam = "L2ParamFamily"),
    function(IC, L2Fam, forceIC = TRUE, name, Risks, Infos, modifyIC = NULL,...){
        mc <- match.call(call = sys.call(sys.parent(1)), expand.dots = FALSE)[-1]
        mc0 <- as.list(mc)
        mc0$IC <- NULL
        mc0$L2Fam <- NULL
        mc0$forceIC <- NULL
        IC.1 <- if(length(formals(IC))==0) function(x) IC(x) else IC
        mc0$Curve <- EuclRandVarList(RealRandVariable(Map = list(IC.1),
                         Domain = Reals()))
        mc0$CallL2Fam <- substitute(L2Fam@fam.call)
        print(mc0)

        IC.0 <- do.call(.IC,mc0)
        print(IC.0)
        if(forceIC) IC.0 <- makeIC(IC.0, L2Fam,...)
        return(IC.0)
    })
## comment 20180809: reverted changes in rev 1110

..IntegrateArgs <- c("lowerTruncQuantile", "upperTruncQuantile",
           "IQR.fac", "subdivisions", "rel.tol", "abs.tol", "stop.on.error",
           "order", "useApply")

.filterEargs <- function(dots){
        dotsI <- list()
        for(item in ..IntegrateArgs) dotsI[[item]] <- dots[[item]]
        return(dotsI)
}