
R Under development (unstable) (2013-02-06 r61845) -- "Unsuffered Consequences"
Copyright (C) 2013 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "RobLox"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('RobLox')
Loading required package: lattice
Loading required package: RColorBrewer
Loading required package: Biobase
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following object is masked from ‘package:stats’:

    xtabs

The following objects are masked from ‘package:base’:

    Filter, Find, Map, Position, Reduce, anyDuplicated, as.data.frame,
    cbind, colnames, duplicated, eval, get, intersect, lapply, mapply,
    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, rank,
    rbind, rep.int, rownames, sapply, setdiff, sort, table, tapply,
    union, unique, unlist

Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for start-up messages (version 0.8)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
Loading required package: SweaveListingUtils
:SweaveListingUtils>  Utilities for Sweave together with
:SweaveListingUtils>  TeX listings package (version 0.6)
:SweaveListingUtils> 
:SweaveListingUtils>  NOTE: Support for this package
:SweaveListingUtils>  will stop soon.
:SweaveListingUtils> 
:SweaveListingUtils>  Package 'knitr' is providing the
:SweaveListingUtils>  same functionality in a better
:SweaveListingUtils>  way.
:SweaveListingUtils> 
:SweaveListingUtils>  Some functions from package 'base'
:SweaveListingUtils>  are intentionally masked ---see
:SweaveListingUtils>  SweaveListingMASK().
:SweaveListingUtils> 
:SweaveListingUtils>  Note that global options are
:SweaveListingUtils>  controlled by
:SweaveListingUtils>  SweaveListingoptions() ---c.f.
:SweaveListingUtils>  ?"SweaveListingoptions".
:SweaveListingUtils> 
:SweaveListingUtils>  For more information see
:SweaveListingUtils>  ?"SweaveListingUtils",
:SweaveListingUtils>  NEWS("SweaveListingUtils")
:SweaveListingUtils>  There is a vignette to this
:SweaveListingUtils>  package; try
:SweaveListingUtils>  vignette("ExampleSweaveListingUtils").


Attaching package: ‘SweaveListingUtils’

The following object is masked from ‘package:base’:

    library, require

:distr>  Object oriented implementation of distributions (version
:distr>  2.4)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: ‘distr’

The following object is masked from ‘package:stats’:

    df, qqplot, sd

Loading required package: distrMod
Loading required package: distrEx
:distrEx>  Extensions of package distr (version 2.4)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See
:distrEx>  distrExMASK().Note: Extreme value distribution
:distrEx>  functionality has been moved to
:distrEx> 
:distrEx>        package "RobExtremes". See distrExMOVED().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: ‘distrEx’

The following object is masked from ‘package:stats’:

    IQR, mad, median, var

Loading required package: RandVar
:RandVar>  Implementation of random variables (version 0.9)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object oriented implementation of probability models
:distrMod>  (version 2.4)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: ‘distrMod’

The following object is masked from ‘package:stats4’:

    confint

The following object is masked from ‘package:stats’:

    confint

The following object is masked from ‘package:base’:

    norm

Loading required package: RobAStBase
Loading required package: rrcov
Loading required package: robustbase
Loading required package: pcaPP
Loading required package: mvtnorm
Scalable Robust Estimators with High Breakdown Point (version 1.3-02)

:RobAStBase>  Robust Asymptotic Statistics (version 0.9)
:RobAStBase> 
:RobAStBase>  Some functions from pkg's 'stats' and 'graphics'
:RobAStBase>  are intentionally masked ---see RobAStBaseMASK().
:RobAStBase> 
:RobAStBase>  Note that global options are controlled by
:RobAStBase>  RobAStBaseoptions() ---c.f. ?"RobAStBaseoptions".
:RobAStBase> 
:RobAStBase>  For more information see ?"RobAStBase",
:RobAStBase>  NEWS("RobAStBase"), as well as
:RobAStBase>    http://robast.r-forge.r-project.org/


Attaching package: ‘RobAStBase’

The following object is masked from ‘package:graphics’:

    clip

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".ExTimings", "RobLox-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   format(x[1L:3L])
+ },
+ pos = 'CheckExEnv')
> 
> cleanEx()
> nameEx("0RobLox-package")
> ### * 0RobLox-package
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RobLox-package
> ### Title: Optimally robust influence curves and estimators for location
> ###   and scale
> ### Aliases: RobLox-package RobLox
> ### Keywords: package
> 
> ### ** Examples
> 
> library(RobLox)
> ind <- rbinom(100, size=1, prob=0.05) 
> x <- rnorm(100, mean=ind*3, sd=(1-ind) + ind*9)
> roblox(x)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  roblox(x = x)
samplesize:   100
estimate:
      mean           sd     
  -0.14805155    0.88449633 
 ( 0.11247138) ( 0.08320902)
asymptotic (co)variance (multiplied with samplesize):
         [,1]     [,2]
[1,] 1.264981 0.000000
[2,] 0.000000 0.692374
Infos:
     method  
[1,] "roblox"
[2,] "roblox"
[3,] "roblox"
     message                                                                              
[1,] "finite-sample corrected radius-minimax estimate for contamination interval [0, 0.5]"
[2,] "least favorable (uncorrected) contamination: 0.057"                                 
[3,] "maximum asymptotic MSE-inefficiency: 4.126"                                         
asymptotic bias:
[1] 1.885026
steps:
[1] 1
> 
> res <- roblox(x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
> estimate(res)
      mean         sd 
-0.1111504  0.8928424 
> confint(res)
A[n] asymptotic (LAN-based) confidence interval:
          2.5 %     97.5 %
mean -0.3066310 0.08433017
sd    0.7472971 1.03838771
Type of estimator: Optimally robust estimate
samplesize:   100
Call by which estimate was produced:
roblox(x = x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
> confint(res, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
          2.5 %    97.5 %
mean -0.3979957 0.1756949
sd    0.6792714 1.1064134
Type of estimator: Optimally robust estimate
samplesize:   100
Call by which estimate was produced:
roblox(x = x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
> pIC(res)
An object of class “ContIC” 
### name:	 IC of contamination type 

### L2-differentiable parametric family:	 normal location and scale family 
### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	-0.111150435088066
sd:	0.892842402157418
trafo:
     mean sd
mean    1  0
sd      0  1

### neighborhood radius:	 0.5455335 

### clip:	[1] 1.679196
### cent:	[1]  0.000000 -0.382342
### stand:
         [,1]     [,2]
[1,] 1.330601 0.000000
[2,] 0.000000 1.054707

### Infos:
     method  
[1,] "roblox"
[2,] "roblox"
[3,] "roblox"
     message                                                                                 
[1,] "finite-sample corrected radius-minimax estimate for contamination interval [0.01, 0.1]"
[2,] "least favorable (uncorrected) contamination: 0.043"                                    
[3,] "maximum asymptotic MSE-inefficiency: 1.441"                                            
> 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D checkIC(pIC(res))
> ##D Risks(pIC(res))
> ##D Infos(pIC(res))
> ##D plot(pIC(res))
> ##D infoPlot(pIC(res))
> ## End(Not run)
> 
> ## row-wise application
> ind <- rbinom(200, size=1, prob=0.05) 
> X <- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
> rowRoblox(X)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X)
samplesize:   100
estimate:
            mean        sd
[1,] -0.09216816 1.1317057
[2,]  0.10169428 0.9520219
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.13"                         
[3,] "roblox" "maximum MSE-inefficiency: 1.668"                             
asymptotic bias:
NULL
steps:
[1] 1
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("0RobLox-package", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("finiteSampleCorrection")
> ### * finiteSampleCorrection
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: finiteSampleCorrection
> ### Title: Function to compute finite-sample corrected radii
> ### Aliases: finiteSampleCorrection
> ### Keywords: robust
> 
> ### ** Examples
> 
> finiteSampleCorrection(n = 3, r = 0.001, model = "locsc")
[1] 0.0296
> finiteSampleCorrection(n = 10, r = 0.02, model = "loc")
[1] 0.0779657
> finiteSampleCorrection(n = 250, r = 0.15, model = "sc")
[1] 0.7348683
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("finiteSampleCorrection", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlOptIC")
> ### * rlOptIC
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlOptIC
> ### Title: Computation of the optimally robust IC for AL estimators
> ### Aliases: rlOptIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlOptIC(r = 0.1)
> distrExOptions("ErelativeTolerance" = 1e-12)
> checkIC(IC1)
precision of centering:	 0 
precision of Fisher consistency:
              mean
mean -7.580384e-06
maximum deviation 
     7.580384e-06 
> distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
> Risks(IC1)
$asMSE
[1] 1.054162

$asBias
[1] 2.053826

$asCov
[1] 1.01198

> cent(IC1)
[1] 0
> clip(IC1)
[1] 2.053826
> stand(IC1)
         [,1]
[1,] 1.054162
> plot(IC1)
NULL
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlOptIC", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.AL")
> ### * rlsOptIC.AL
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.AL
> ### Title: Computation of the optimally robust IC for AL estimators
> ### Aliases: rlsOptIC.AL
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.AL(r = 0.1, check = TRUE)
Fisher consistency of eta.loc:	 -1.743783e-10 
centering of eta.sc:	 -3.904033e-10 
Fisher consistency of eta.sc:	 2.926179e-09 
MSE equation:	 1.207368e-14 
> distrExOptions("ErelativeTolerance" = 1e-12)
> checkIC(IC1)
precision of centering:	 0 -6.039278e-07 
precision of Fisher consistency:
             mean            sd
mean -1.10248e-06  0.000000e+00
sd    0.00000e+00 -1.685676e-05
maximum deviation 
     1.685676e-05 
> distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
> Risks(IC1)
$asMSE
[1] 1.647765

$asBias
[1] 3.182504

$trAsCov
[1] 1.546482

$asCov
         [,1]      [,2]
[1,] 1.017104 0.0000000
[2,] 0.000000 0.5293779

> cent(IC1)
[1]  0.00000000 -0.02574219
> clip(IC1)
[1] 3.182504
> stand(IC1)
        [,1]      [,2]
[1,] 1.05189 0.0000000
[2,] 0.00000 0.5958748
> 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D plot(IC1)
> ##D infoPlot(IC1)
> ##D 
> ##D ## k-step estimation
> ##D ## better use function roblox (see ?roblox)
> ##D ## 1. data: random sample
> ##D ind <- rbinom(100, size=1, prob=0.05) 
> ##D x <- rnorm(100, mean=0, sd=(1-ind) + ind*9)
> ##D mean(x)
> ##D sd(x)
> ##D median(x)
> ##D mad(x)
> ##D 
> ##D ## 2. Kolmogorov(-Smirnov) minimum distance estimator (default)
> ##D ## -> we use it as initial estimate for one-step construction
> ##D (est0 <- MDEstimator(x, ParamFamily = NormLocationScaleFamily()))
> ##D 
> ##D ## 3.1 one-step estimation: radius known
> ##D IC1 <- rlsOptIC.AL(r = 0.5, mean = estimate(est0)[1], sd = estimate(est0)[2])
> ##D (est1 <- oneStepEstimator(x, IC1, est0))
> ##D 
> ##D ## 3.2 k-step estimation: radius known
> ##D ## Choose k = 3
> ##D (est2 <- kStepEstimator(x, IC1, est0, steps = 3L))
> ##D 
> ##D ## 4.1 one-step estimation: radius unknown
> ##D ## take least favorable radius r = 0.579
> ##D ## cf. Table 8.1 in Kohl(2005)
> ##D IC2 <- rlsOptIC.AL(r = 0.579, mean = estimate(est0)[1], sd = estimate(est0)[2])
> ##D (est3 <- oneStepEstimator(x, IC2, est0))
> ##D 
> ##D ## 4.2 k-step estimation: radius unknown
> ##D ## take least favorable radius r = 0.579
> ##D ## cf. Table 8.1 in Kohl(2005)
> ##D ## choose k = 3
> ##D (est4 <- kStepEstimator(x, IC2, est0, steps = 3L))
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.AL", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.An1")
> ### * rlsOptIC.An1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.An1
> ### Title: Computation of the optimally robust IC for An1 estimators
> ### Aliases: rlsOptIC.An1
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.An1(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 1.410025e-07 
precision of Fisher consistency:
             mean           sd
mean 2.530605e-08 0.000000e+00
sd   0.000000e+00 3.875467e-06
maximum deviation 
     3.875467e-06 
> Risks(IC1)
$asMSE
[1] 1.673449

$asBias
[1] 3.341956

$asCov
[1] 1.561762

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.An1" "optimally robust IC for An1 estimators and 'asMSE'"
[2,] "rlsOptIC.An1" "where a = 1.577"                                   
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D plot(IC1)
> ##D infoPlot(IC1)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.An1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.An2")
> ### * rlsOptIC.An2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.An2
> ### Title: Computation of the optimally robust IC for An2 estimators
> ### Aliases: rlsOptIC.An2
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.An2(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -0.0001066371 
precision of Fisher consistency:
              mean            sd
mean -4.006394e-07  0.000000e+00
sd    0.000000e+00 -1.496408e-05
maximum deviation 
     0.0001066371 
> Risks(IC1)
$asMSE
[1] 1.656837

$asBias
[1] 3.268231

$asCov
[1] 1.550024

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.An2" "optimally robust IC for An2 estimators and 'asMSE'"
[2,] "rlsOptIC.An2" "where a = 1.813 and k = 2.267"                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.An2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.AnMad")
> ### * rlsOptIC.AnMad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.AnMad
> ### Title: Computation of the optimally robust IC for AnMad estimators
> ### Aliases: rlsOptIC.AnMad
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.AnMad(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.569591e-07 
precision of Fisher consistency:
              mean            sd
mean -4.044557e-07  0.000000e+00
sd    0.000000e+00 -6.821323e-05
maximum deviation 
     6.821323e-05 
> Risks(IC1)
$asMSE
[1] 2.434119

$asBias
[1] 2.412581

$asCov
[1] 2.375914

> Infos(IC1)
     method           message                                               
[1,] "rlsOptIC.AnMad" "optimally robust IC for AnMad estimators and 'asMSE'"
[2,] "rlsOptIC.AnMad" "where a = 1.814"                                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.AnMad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.BM")
> ### * rlsOptIC.BM
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.BM
> ### Title: Computation of the optimally robust IC for BM estimators
> ### Aliases: rlsOptIC.BM
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.BM(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -1.246469e-06 
precision of Fisher consistency:
              mean            sd
mean -2.355426e-06  0.000000e+00
sd    0.000000e+00 -1.737383e-05
maximum deviation 
     1.737383e-05 
> Risks(IC1)
$asMSE
[1] 1.659506

$asBias
[1] 3.339524

$asCov
[1] 1.547982

> Infos(IC1)
     method       
[1,] "rlsOptIC.BM"
[2,] "rlsOptIC.BM"
     message                                                                  
[1,] "optimally robust IC for BM estimators and 'asMSE'"                      
[2,] " where b.loc = 2.121 , b.sc.0 = 4.461 , alpha = 1.053 and gamma = 0.578"
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.BM", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Ha3")
> ### * rlsOptIC.Ha3
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Ha3
> ### Title: Computation of the optimally robust IC for Ha3 estimators
> ### Aliases: rlsOptIC.Ha3
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Ha3(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -2.659214e-07 
precision of Fisher consistency:
              mean            sd
mean -8.538336e-07  0.000000e+00
sd    0.000000e+00 -9.691769e-06
maximum deviation 
     9.691769e-06 
> Risks(IC1)
$asMSE
[1] 1.649969

$asBias
[1] 3.215669

$asCov
[1] 1.546563

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Ha3" "optimally robust IC for Ha3 estimators and 'asMSE'"
[2,] "rlsOptIC.Ha3" "where a = 2.132 , b = 2.17 and c = 7.059"          
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D plot(IC1)
> ##D infoPlot(IC1)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Ha3", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Ha4")
> ### * rlsOptIC.Ha4
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Ha4
> ### Title: Computation of the optimally robust IC for Ha4 estimators
> ### Aliases: rlsOptIC.Ha4
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Ha4(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -0.0001069318 
precision of Fisher consistency:
              mean            sd
mean -2.265319e-06  0.000000e+00
sd    0.000000e+00 -1.498731e-05
maximum deviation 
     0.0001069318 
> Risks(IC1)
$asMSE
[1] 1.650944

$asBias
[1] 3.230698

$asCov
[1] 1.54657

> Infos(IC1)
     method         message                                               
[1,] "rlsOptIC.Ha4" "optimally robust IC for Ha4 estimators and 'asMSE'"  
[2,] "rlsOptIC.Ha4" "where a = 1.947 , b = 5.244 , c = 6.34 and k = 2.267"
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Ha4", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.HaMad")
> ### * rlsOptIC.HaMad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.HaMad
> ### Title: Computation of the optimally robust IC for HuMad estimators
> ### Aliases: rlsOptIC.HaMad
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.HaMad(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.569591e-07 
precision of Fisher consistency:
              mean            sd
mean -2.041724e-06  0.000000e+00
sd    0.000000e+00 -6.821323e-05
maximum deviation 
     6.821323e-05 
> Risks(IC1)
$asMSE
[1] 2.428232

$asBias
[1] 2.358787

$asCov
[1] 2.372593

> Infos(IC1)
     method           message                                               
[1,] "rlsOptIC.HaMad" "optimally robust IC for HaMad estimators and 'asMSE'"
[2,] "rlsOptIC.HaMad" "where a = 1.944 , b = 4.368 , c = 10.51"             
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.HaMad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Hu1")
> ### * rlsOptIC.Hu1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Hu1
> ### Title: Computation of the optimally robust IC for Hu1 estimators
> ### Aliases: rlsOptIC.Hu1
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Hu1(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -2.085425e-06 
precision of Fisher consistency:
              mean            sd
mean -3.746843e-06  0.000000e+00
sd    0.000000e+00 -1.350353e-05
maximum deviation 
     1.350353e-05 
> Risks(IC1)
$asMSE
[1] 1.654518

$asBias
[1] 3.281352

$asCov
[1] 1.546845

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Hu1" "optimally robust IC for Hu1 estimators and 'asMSE'"
[2,] "rlsOptIC.Hu1" "where k = 2.197"                                   
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Hu1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Hu2")
> ### * rlsOptIC.Hu2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Hu2
> ### Title: Computation of the optimally robust IC for Hu2 estimators
> ### Aliases: rlsOptIC.Hu2
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Hu2(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.187336e-07 
precision of Fisher consistency:
              mean            sd
mean -2.563384e-06  0.000000e+00
sd    0.000000e+00 -1.321969e-05
maximum deviation 
     1.321969e-05 
> Risks(IC1)
$asMSE
[1] 1.650944

$asBias
[1] 3.227897

$asCov
[1] 1.546751

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Hu2" "optimally robust IC for Hu2 estimators and 'asMSE'"
[2,] "rlsOptIC.Hu2" "where k = 1.945 and c = 2.266"                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Hu2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Hu2a")
> ### * rlsOptIC.Hu2a
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Hu2a
> ### Title: Computation of the optimally robust IC for Hu2a estimators
> ### Aliases: rlsOptIC.Hu2a
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Hu2a(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -1.52497e-06 
precision of Fisher consistency:
             mean            sd
mean -3.15714e-06  0.000000e+00
sd    0.00000e+00 -1.321476e-05
maximum deviation 
     1.321476e-05 
> Risks(IC1)
$asMSE
[1] 1.654518

$asBias
[1] 3.283358

$asCov
[1] 1.546714

> Infos(IC1)
     method          message                                              
[1,] "rlsOptIC.Hu2a" "optimally robust IC for Hu2a estimators and 'asMSE'"
[2,] "rlsOptIC.Hu2a" "where k1 = 0 and k2 = 2.198"                        
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Hu2a", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Hu3")
> ### * rlsOptIC.Hu3
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Hu3
> ### Title: Computation of the optimally robust IC for Hu3 estimators
> ### Aliases: rlsOptIC.Hu3
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Hu3(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -8.525774e-05 
precision of Fisher consistency:
              mean            sd
mean -2.132286e-06  0.000000e+00
sd    0.000000e+00 -1.574855e-05
maximum deviation 
     8.525774e-05 
> Risks(IC1)
$asMSE
[1] 1.650946

$asBias
[1] 3.232909

$asCov
[1] 1.546429

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Hu3" "optimally robust IC for Hu3 estimators and 'asMSE'"
[2,] "rlsOptIC.Hu3" "where k = 1.948 , c1 = 0.112 and c2 = 2.268"       
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Hu3", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.HuMad")
> ### * rlsOptIC.HuMad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.HuMad
> ### Title: Computation of the optimally robust IC for HuMad estimators
> ### Aliases: rlsOptIC.HuMad
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.HuMad(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.569591e-07 
precision of Fisher consistency:
              mean            sd
mean -1.987572e-06  0.000000e+00
sd    0.000000e+00 -6.821323e-05
maximum deviation 
     6.821323e-05 
> Risks(IC1)
$asMSE
[1] 2.428225

$asBias
[1] 2.361918

$asCov
[1] 2.372439

> Infos(IC1)
     method           message                                               
[1,] "rlsOptIC.HuMad" "optimally robust IC for HuMad estimators and 'asMSE'"
[2,] "rlsOptIC.HuMad" "where k = 1.948"                                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.HuMad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.M")
> ### * rlsOptIC.M
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.M
> ### Title: Computation of the optimally robust IC for M estimators
> ### Aliases: rlsOptIC.M
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.M(r = 0.1, check = TRUE)
constraint a1:	 4.682285e-09 
constraint a3:	 -1.033529e-08 
MSE equation:	 -3.383516e-12 
> distrExOptions("ErelativeTolerance" = 1e-12)
> checkIC(IC1, NormLocationScaleFamily())
precision of centering:	 -1.418367e-20 9.579943e-06 
precision of Fisher consistency:
             mean            sd
mean 1.646253e-05 -8.358660e-22
sd   1.313976e-21  2.094876e-05
maximum deviation 
     2.094876e-05 
> distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25)
> Risks(IC1)
$asMSE
[1] 1.648004

$asBias
[1] 3.186872

$asCov
[1] 1.546442

> Infos(IC1)
     method       message                                                      
[1,] "rlsOptIC.M" "optimally robust IC for M estimators and 'asMSE'"           
[2,] "rlsOptIC.M" "where a1 = 0.724 , a3 = 0.343 , b = 3.187 and gamma = 0.575"
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.M", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.MM2")
> ### * rlsOptIC.MM2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.MM2
> ### Title: Computation of the optimally robust IC for MM2 estimators
> ### Aliases: rlsOptIC.MM2
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.MM2(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.066522e-07 
precision of Fisher consistency:
              mean            sd
mean -2.225204e-06  0.000000e+00
sd    0.000000e+00 -1.566028e-05
maximum deviation 
     1.566028e-05 
> Risks(IC1)
$asMSE
[1] 1.666343

$asBias
[1] 3.256951

$asCov
[1] 1.560266

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.MM2" "optimally robust IC for MM2 estimators and 'asMSE'"
[2,] "rlsOptIC.MM2" "where c = 2.159 and d = 3.337"                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.MM2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Tu1")
> ### * rlsOptIC.Tu1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Tu1
> ### Title: Computation of the optimally robust IC for Tu1 estimators
> ### Aliases: rlsOptIC.Tu1
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Tu1(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 1.022418e-07 
precision of Fisher consistency:
              mean           sd
mean -3.649066e-08 0.000000e+00
sd    0.000000e+00 2.888236e-06
maximum deviation 
     2.888236e-06 
> Risks(IC1)
$asMSE
[1] 1.672751

$asBias
[1] 3.335032

$asCov
[1] 1.561527

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Tu1" "optimally robust IC for Tu1 estimators and 'asMSE'"
[2,] "rlsOptIC.Tu1" "where a = 5.527"                                   
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Tu1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.Tu2")
> ### * rlsOptIC.Tu2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.Tu2
> ### Title: Computation of the optimally robust IC for Tu2 estimators
> ### Aliases: rlsOptIC.Tu2
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.Tu2(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -3.919236e-07 
precision of Fisher consistency:
              mean            sd
mean -5.447399e-07  0.000000e+00
sd    0.000000e+00 -1.437669e-05
maximum deviation 
     1.437669e-05 
> Risks(IC1)
$asMSE
[1] 1.656762

$asBias
[1] 3.265842

$asCov
[1] 1.550105

> Infos(IC1)
     method         message                                             
[1,] "rlsOptIC.Tu2" "optimally robust IC for Tu2 estimators and 'asMSE'"
[2,] "rlsOptIC.Tu2" "where a = 6.357 and k = 2.264"                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.Tu2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rlsOptIC.TuMad")
> ### * rlsOptIC.TuMad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rlsOptIC.TuMad
> ### Title: Computation of the optimally robust IC for TuMad estimators
> ### Aliases: rlsOptIC.TuMad
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rlsOptIC.TuMad(r = 0.1)
> checkIC(IC1)
precision of centering:	 0 -6.569591e-07 
precision of Fisher consistency:
              mean            sd
mean -5.410012e-07  0.000000e+00
sd    0.000000e+00 -6.821323e-05
maximum deviation 
     6.821323e-05 
> Risks(IC1)
$asMSE
[1] 2.434044

$asBias
[1] 2.41339

$asCov
[1] 2.375799

> Infos(IC1)
     method           message                                               
[1,] "rlsOptIC.TuMad" "optimally robust IC for TuMad estimators and 'asMSE'"
[2,] "rlsOptIC.TuMad" "where a = 6.352"                                     
> plot(IC1)
NULL
NULL
> infoPlot(IC1)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rlsOptIC.TuMad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("roblox")
> ### * roblox
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: roblox
> ### Title: Optimally robust estimator for location and/or scale
> ### Aliases: roblox
> ### Keywords: robust
> 
> ### ** Examples
> 
> ind <- rbinom(100, size=1, prob=0.05) 
> x <- rnorm(100, mean=ind*3, sd=(1-ind) + ind*9)
> 
> ## amount of gross errors known
> res1 <- roblox(x, eps = 0.05, returnIC = TRUE)
> estimate(res1)
      mean         sd 
-0.1122987  0.8880179 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D confint(res1)
> ##D confint(res1, method = symmetricBias())
> ##D pIC(res1)
> ##D checkIC(pIC(res1))
> ##D Risks(pIC(res1))
> ##D Infos(pIC(res1))
> ##D plot(pIC(res1))
> ##D infoPlot(pIC(res1))
> ## End(Not run)
> 
> ## amount of gross errors unknown
> res2 <- roblox(x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
> estimate(res2)
      mean         sd 
-0.1111504  0.8928424 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D confint(res2)
> ##D confint(res2, method = symmetricBias())
> ##D pIC(res2)
> ##D checkIC(pIC(res2))
> ##D Risks(pIC(res2))
> ##D Infos(pIC(res2))
> ##D plot(pIC(res2))
> ##D infoPlot(pIC(res2))
> ## End(Not run)
> 
> ## estimator comparison
> # classical optimal (non-robust)
> c(mean(x), sd(x))
[1] 0.1337233 1.8683758
> 
> # most robust
> c(median(x), mad(x))
[1] -0.08687757  0.83485642
> 
> # optimally robust (amount of gross errors known)
> estimate(res1)
      mean         sd 
-0.1122987  0.8880179 
> 
> # optimally robust (amount of gross errors unknown)
> estimate(res2)
      mean         sd 
-0.1111504  0.8928424 
> 
> # Kolmogorov(-Smirnov) minimum distance estimator (robust)
> (ks.est <- MDEstimator(x, ParamFamily = NormLocationScaleFamily()))
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = NormLocationScaleFamily())
samplesize:   100
estimate:
       mean          sd 
-0.03980472  0.90817692 
Criterion:
Kolmogorov distance 
          0.0568421 
> 
> # optimally robust (amount of gross errors known)
> roblox(x, eps = 0.05, initial.est = estimate(ks.est))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  roblox(x = x, eps = 0.05, initial.est = estimate(ks.est))
samplesize:   100
estimate:
      mean           sd     
  -0.11586692    0.90365737 
 ( 0.10307092) ( 0.07651628)
asymptotic (co)variance (multiplied with samplesize):
         [,1]      [,2]
[1,] 1.062361 0.0000000
[2,] 0.000000 0.5854741
Infos:
     method  
[1,] "roblox"
     message                                                                                       
[1,] "finite-sample corrected optimally robust estimate for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
      sd 
1.035576 
steps:
[1] 1
> 
> # Cramer von Mises minimum distance estimator (robust)
> (CvM.est <- MDEstimator(x, ParamFamily = NormLocationScaleFamily(), distance = CvMDist))
Evaluations of Minimum CvM distance estimate:
---------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = NormLocationScaleFamily(), distance = CvMDist)
samplesize:   100
estimate:
       mean          sd 
-0.06995363  0.89265661 
Criterion:
CvM distance 
  0.02436665 
> 
> # optimally robust (amount of gross errors known)
> roblox(x, eps = 0.05, initial.est = estimate(CvM.est))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  roblox(x = x, eps = 0.05, initial.est = estimate(CvM.est))
samplesize:   100
estimate:
      mean           sd     
  -0.11421421    0.89779415 
 ( 0.10240216) ( 0.07601982)
asymptotic (co)variance (multiplied with samplesize):
        [,1]      [,2]
[1,] 1.04862 0.0000000
[2,] 0.00000 0.5779013
Infos:
     method  
[1,] "roblox"
     message                                                                                       
[1,] "finite-sample corrected optimally robust estimate for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
      sd 
1.028857 
steps:
[1] 1
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("roblox", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rowRoblox")
> ### * rowRoblox
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rowRoblox and colRoblox
> ### Title: Optimally robust estimation for location and/or scale
> ### Aliases: rowRoblox colRoblox
> ### Keywords: robust
> 
> ### ** Examples
> 
> ind <- rbinom(200, size=1, prob=0.05) 
> X <- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
> rowRoblox(X)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X)
samplesize:   100
estimate:
            mean        sd
[1,] -0.07374287 0.9125353
[2,] -0.03062735 1.0281642
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.13"                         
[3,] "roblox" "maximum MSE-inefficiency: 1.668"                             
asymptotic bias:
NULL
steps:
[1] 1
> rowRoblox(X, k = 3)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X, k = 3)
samplesize:   100
estimate:
            mean        sd
[1,] -0.06295037 0.9208882
[2,] -0.03422397 1.0258818
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.13"                         
[3,] "roblox" "maximum MSE-inefficiency: 1.668"                             
asymptotic bias:
NULL
steps:
[1] 3
> rowRoblox(X, eps = 0.05)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X, eps = 0.05)
samplesize:   100
estimate:
              mean        sd
[1,] -0.0316323762 0.9147275
[2,]  0.0003312827 1.0508015
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 1
> rowRoblox(X, eps = 0.05, k = 3)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X, eps = 0.05, k = 3)
samplesize:   100
estimate:
             mean        sd
[1,] -0.028278572 0.9274339
[2,] -0.001566506 1.0511230
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 3
> 
> X1 <- t(X)
> colRoblox(X1)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X1)
samplesize:   100
estimate:
            mean        sd
[1,] -0.07374287 0.9125353
[2,] -0.03062735 1.0281642
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.13"                         
[3,] "roblox" "maximum MSE-inefficiency: 1.668"                             
asymptotic bias:
NULL
steps:
[1] 1
> colRoblox(X1, k = 3)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X1, k = 3)
samplesize:   100
estimate:
            mean        sd
[1,] -0.06295037 0.9208882
[2,] -0.03422397 1.0258818
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.13"                         
[3,] "roblox" "maximum MSE-inefficiency: 1.668"                             
asymptotic bias:
NULL
steps:
[1] 3
> colRoblox(X1, eps = 0.05)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X1, eps = 0.05)
samplesize:   100
estimate:
              mean        sd
[1,] -0.0316323762 0.9147275
[2,]  0.0003312827 1.0508015
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 1
> colRoblox(X1, eps = 0.05, k = 3)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X1, eps = 0.05, k = 3)
samplesize:   100
estimate:
             mean        sd
[1,] -0.028278572 0.9274339
[2,] -0.001566506 1.0511230
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.05 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 3
> 
> X2 <- rbind(rnorm(100, mean = -2, sd = 3), rnorm(100, mean = -1, sd = 4))
> rowRoblox(X2, sd = c(3, 4))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X2, sd = c(3, 4))
samplesize:   100
estimate:
          mean
[1,] -1.710155
[2,] -1.429392
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.067"                        
[3,] "roblox" "maximum MSE-inefficiency: 1.195"                             
asymptotic bias:
NULL
steps:
[1] 1
> rowRoblox(X2, eps = 0.03, sd = c(3, 4))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X2, sd = c(3, 4), eps = 0.03)
samplesize:   100
estimate:
          mean
[1,] -1.728845
[2,] -1.360515
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.03 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 1
> rowRoblox(X2, sd = c(3, 4), k = 4)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X2, sd = c(3, 4), k = 4)
samplesize:   100
estimate:
          mean
[1,] -1.715414
[2,] -1.426938
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.067"                        
[3,] "roblox" "maximum MSE-inefficiency: 1.195"                             
asymptotic bias:
NULL
steps:
[1] 4
> rowRoblox(X2, eps = 0.03, sd = c(3, 4), k = 4)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  rowRoblox(x = X2, sd = c(3, 4), eps = 0.03, k = 4)
samplesize:   100
estimate:
          mean
[1,] -1.729414
[2,] -1.342921
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.03 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 4
> 
> X3 <- cbind(rnorm(100, mean = -2, sd = 3), rnorm(100, mean = 1, sd = 2))
> colRoblox(X3, mean = c(-2, 1))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X3, mean = c(-2, 1))
samplesize:   100
estimate:
           sd
[1,] 2.989264
[2,] 2.178403
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.106"                        
[3,] "roblox" "maximum MSE-inefficiency: 2.095"                             
asymptotic bias:
NULL
steps:
[1] 1
> colRoblox(X3, eps = 0.02, mean = c(-2, 1))
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X3, mean = c(-2, 1), eps = 0.02)
samplesize:   100
estimate:
           sd
[1,] 2.951325
[2,] 2.181291
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.02 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 1
> colRoblox(X3, mean = c(-2, 1), k = 4)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X3, mean = c(-2, 1), k = 4)
samplesize:   100
estimate:
           sd
[1,] 3.004454
[2,] 2.183808
Infos:
     method   message                                                       
[1,] "roblox" "radius-minimax estimates for contamination interval [0, 0.5]"
[2,] "roblox" "least favorable contamination: 0.106"                        
[3,] "roblox" "maximum MSE-inefficiency: 2.095"                             
asymptotic bias:
NULL
steps:
[1] 4
> colRoblox(X3, eps = 0.02, mean = c(-2, 1), k = 4)
Evaluations of Optimally robust estimate:
-----------------------------------------
An object of class “Estimate” 
generated by call
  colRoblox(x = X3, mean = c(-2, 1), eps = 0.02, k = 4)
samplesize:   100
estimate:
           sd
[1,] 2.983268
[2,] 2.186129
Infos:
     method  
[1,] "roblox"
     message                                                                
[1,] "optimally robust estimates for contamination 'eps' = 0.02 and 'asMSE'"
asymptotic bias:
NULL
steps:
[1] 4
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rowRoblox", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rsOptIC")
> ### * rsOptIC
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rsOptIC
> ### Title: Computation of the optimally robust IC for AL estimators
> ### Aliases: rsOptIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- rsOptIC(r = 0.1)
> distrExOptions("ErelativeTolerance" = 1e-12)
> checkIC(IC1)
precision of centering:	 -5.00529e-07 
precision of Fisher consistency:
              scale
scale -1.394372e-05
maximum deviation 
     1.394372e-05 
> distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
> Risks(IC1)
$asMSE
[1] 0.5967817

$asBias
[1] 2.492635

$asCov
[1] 0.5346494

> cent(IC1)
[1] -0.02492634
> clip(IC1)
[1] 2.492635
> stand(IC1)
          [,1]
[1,] 0.5967817
> plot(IC1)
NULL
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rsOptIC", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("showdown")
> ### * showdown
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: showdown
> ### Title: Estimator Showdown by Monte-Carlo Study.
> ### Aliases: showdown
> ### Keywords: robust
> 
> ### ** Examples
> 
> library(MASS)
> ## compare with Huber's Proposal 2
> showdown(n = 20, M = 100, eps = 0.02, contD = Norm(mean = 3, sd = 3), 
+          estfun = function(x){ unlist(hubers(x)) },
+          plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)
dev.new(): using pdf(file="Rplots1.pdf")
                               ML      Med Competitor       rmx
n x empMSE (loc)         1.151729 1.571687  1.0217407 1.0412422
relMSE (loc)             1.106111 1.509434  0.9812710 1.0000000
n x empMSE (scale)       1.086260 1.493500  0.7204599 0.6113725
relMSE (scale)           1.776757 2.442864  1.1784303 1.0000000
n x empMSE (loc + scale) 2.237989 3.065187  1.7422006 1.6526147
relMSE (loc + scale)     1.354211 1.854750  1.0542086 1.0000000
> 
> ## compare with Huber M estimator with MAD scale
> showdown(n = 20, M = 100, eps = 0.02, contD = Norm(mean = 3, sd = 3), 
+          estfun = function(x){ unlist(huber(x)) },
+          plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)
dev.new(): using pdf(file="Rplots2.pdf")
dev.new(): using pdf(file="Rplots3.pdf")
                               ML      Med Competitor       rmx
n x empMSE (loc)         1.151729 1.571687   1.091427 1.0412422
relMSE (loc)             1.106111 1.509434   1.048197 1.0000000
n x empMSE (scale)       1.086260 1.493500   1.493499 0.6113725
relMSE (scale)           1.776757 2.442864   2.442862 1.0000000
n x empMSE (loc + scale) 2.237989 3.065187   2.584925 1.6526147
relMSE (loc + scale)     1.354211 1.854750   1.564143 1.0000000
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("showdown", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  72.904 0.34 73.52 0 0 
> grDevices::dev.off()
pdf 
  2 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
