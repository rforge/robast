
R Under development (unstable) (2019-02-27 r76167) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "RobAStBase"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('RobAStBase')
Loading required package: rrcov
Loading required package: robustbase
Scalable Robust Estimators with High Breakdown Point (version 1.4-7)

Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for Start-Up Messages (version 0.9.6)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
:distr>  Object Oriented Implementation of Distributions (version
:distr>  2.8.0)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: 'distr'

The following objects are masked from 'package:stats':

    df, qqplot, sd

Loading required package: distrEx
:distrEx>  Extensions of Package 'distr' (version 2.8.0)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See
:distrEx>  distrExMASK().Note: Extreme value distribution
:distrEx>  functionality has been moved to
:distrEx> 
:distrEx>        package "RobExtremes". See distrExMOVED().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: 'distrEx'

The following objects are masked from 'package:stats':

    IQR, mad, median, var

Loading required package: distrMod
Loading required package: RandVar
:RandVar>  Implementation of Random Variables (version 1.2.0)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object Oriented Implementation of Probability Models
:distrMod>  (version 2.8.0)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: 'distrMod'

The following object is masked from 'package:stats4':

    confint

The following object is masked from 'package:stats':

    confint

The following object is masked from 'package:base':

    norm

:RobAStBase>  Robust Asymptotic Statistics (version 1.2.0)
:RobAStBase> 
:RobAStBase>  Some functions from pkg's 'stats' and 'graphics'
:RobAStBase>  are intentionally masked ---see RobAStBaseMASK().
:RobAStBase> 
:RobAStBase>  Note that global options are controlled by
:RobAStBase>  RobAStBaseoptions() ---c.f. ?"RobAStBaseoptions".
:RobAStBase> 
:RobAStBase>  For more information see ?"RobAStBase",
:RobAStBase>  NEWS("RobAStBase"), as well as
:RobAStBase>    http://robast.r-forge.r-project.org/


Attaching package: 'RobAStBase'

The following object is masked from 'package:graphics':

    clip

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("0RobAStBase-package")
> ### * 0RobAStBase-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBase-package
> ### Title: Robust Asymptotic Statistics
> ### Aliases: RobAStBase-package RobAStBase
> ### Keywords: package
> 
> ### ** Examples
> 
> library(RobAStBase)
> 
> ## some L2 differentiable parametric family from package distrMod, e.g.
> B <- BinomFamily(size = 25, prob = 0.25) 
> 
> ## classical optimal IC
> IC0 <- optIC(model = B, risk = asCov())
> plot(IC0) # plot IC
> checkIC(IC0, B)
precision of centering:	 -2.112044e-17 
precision of Fisher consistency:
              prob
prob -2.220446e-16
precision of Fisher consistency - relative error [%]:
              prob
prob -2.220446e-14
maximum deviation 
                0 
> 
> 
> 
> cleanEx()
> nameEx("ALEstimate-class")
> ### * ALEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ALEstimate-class
> ### Title: ALEstimate-class.
> ### Aliases: ALEstimate-class MCALEstimate-class ML.ALEstimate-class
> ###   CvMMD.ALEstimate-class pIC pIC,ALEstimate-method
> ###   pIC,MCEstimate-method pIC,MLEstimate-method pIC,CvMMDEstimate-method
> ###   pIC,MCALEstimate-method pIC,ML.ALEstimate-method
> ###   pIC,CvMMD.ALEstimate-method asbias asbias,ALEstimate-method
> ###   show,ALEstimate-method show,MCALEstimate-method
> ###   confint,ALEstimate,missing-method
> ###   confint,ALEstimate,symmetricBias-method
> ###   confint,ALEstimate,onesidedBias-method
> ###   confint,ALEstimate,asymmetricBias-method
> ###   .checkEstClassForParamFamily,ANY,MLEstimate-method
> ###   .checkEstClassForParamFamily,ANY,CvMMDEstimate-method getPIC
> ###   getPIC,ANY-method getPIC,MLEstimate-method
> ###   getPIC,CvMMDEstimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("ALEstimate")
Evaluations of Asymptotically linear estimate:
----------------------------------------------
An object of class "ALEstimate" 
generated by call
  `{}`()
estimate:
numeric(0)
asymptotic bias:
NULL
> 
> ## data example
> set.seed(123)
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> mle <- MLEstimator(x,G)
> (picM <- pIC(mle))
An object of class "IC" 
### name:	 Classical optimal influence curve for Gamma family 
### L2-differentiable parametric family:	 Gamma family 

### 'Curve':	An object of class "EuclRandVarList" 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 2 
Range:	Real Space with dimension 1 

### Infos:
     method  message                                  
[1,] "optIC" "optimal IC in sense of Cramer-Rao bound"
> 
> ## Kolmogorov(-Smirnov) minimum distance estimator
> ke <- KolmogorovMDEstimator(x = x, ParamFamily = G)
> pIC(ke) ## gives NULL
NULL
> 
> ## von Mises minimum distance estimator with default mu
> 
> ## No test: 
>  ## to save time for CRAN
> system.time(me <- CvMMDEstimator(x = x, ParamFamily = G))
   user  system elapsed 
   2.31    0.05    3.92 
> str(me@pIC) ## a call
 language getPIC(new("CvMMDEstimate", criterion = c(`CvM distance` = 0.0318540469774686),      criterion.fct = function (sc| __truncated__ ...
> system.time(pIC0 <- pIC(me))
   user  system elapsed 
   3.32    0.06    4.41 
> str(me@pIC) ## now filled
Formal class 'IC' [package "RobAStBase"] with 6 slots
  ..@ CallL2Fam: language GammaFamily(trafo = matrix(c(1, 0, 0, 1), ncol = 2, dimnames = list(c("scale",  "shape"), c("scale", "shape"))), | __truncated__
  ..@ modifyIC : NULL
  ..@ name     : chr "IC of CvM MDE"
  ..@ Curve    :Formal class 'EuclRandVarList' [package "RandVar"] with 1 slot
  .. .. ..@ .Data:List of 1
  .. .. .. ..$ :Formal class 'EuclRandVariable' [package "RandVar"] with 3 slots
  .. .. .. .. .. ..@ Map   :List of 2
  .. .. .. .. .. .. ..$ :function (x)  
  .. .. .. .. .. .. .. ..- attr(*, "srcref")= 'srcref' int [1:8] 558 23 558 78 23 78 5827 5827
  .. .. .. .. .. .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x10f1f9a0> 
  .. .. .. .. .. .. ..$ :function (x)  
  .. .. .. .. .. .. .. ..- attr(*, "srcref")= 'srcref' int [1:8] 558 23 558 78 23 78 5827 5827
  .. .. .. .. .. .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x10f1f9a0> 
  .. .. .. .. .. ..@ Domain:Formal class 'Reals' [package "distr"] with 2 slots
  .. .. .. .. .. .. .. ..@ dimension: num 1
  .. .. .. .. .. .. .. ..@ name     : chr "Real Space"
  .. .. .. .. .. ..@ Range :Formal class 'Reals' [package "distr"] with 2 slots
  .. .. .. .. .. .. .. ..@ dimension: num 1
  .. .. .. .. .. .. .. ..@ name     : chr "Real Space"
  ..@ Risks    :List of 1
  .. ..$ asCov:Formal class 'PosSemDefSymmMatrix' [package "distr"] with 1 slot
  .. .. .. ..@ .Data: num [1:2, 1:2] 0.725 -3.424 -3.424 20.474
  .. .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. .. ..$ : chr [1:2] "scale" "shape"
  .. .. .. .. .. ..$ : chr [1:2] "scale" "shape"
  ..@ Infos    : chr [1, 1:2] "pIC-CvM-MDE" "computed by .CvMMDCovariance[WithMux]"
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "method" "message"
> ## End(No test)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("BdStWeight-class")
> ### * BdStWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BdStWeight-class
> ### Title: Robust Weight classes for bounded, standardized weights
> ### Aliases: BdStWeight-class stand,BdStWeight-method
> ###   stand<-,BdStWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("BdStWeight")
An object of class "BdStWeight"
Slot "stand":
     [,1]
[1,]    1

Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function(x) 1
<bytecode: 0x0d28e0e0>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("BoundedWeight-class")
> ### * BoundedWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BoundedWeight-class
> ### Title: Robust Weight classes for bounded weights
> ### Aliases: BoundedWeight-class clip,BoundedWeight-method
> ###   clip<-,BoundedWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("BoundedWeight")
An object of class "BoundedWeight"
Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function(x) 1
<bytecode: 0x0ce3dc08>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("ComparePlotWrapper")
> ### * ComparePlotWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ComparePlot
> ### Title: Wrapper function for function comparePlot
> ### Aliases: ComparePlot
> 
> ### ** Examples
> 
> # Gamma
> fam <- GammaFamily()
> rfam <- InfRobModel(fam, ContNeighborhood(0.5))
> IC1 <- optIC(model = fam, risk = asCov())
> IC2 <- makeIC(list(function(x)sin(x),function(x)x^2), L2Fam = fam)
> Y <- distribution(fam)
> y <- r(Y)(100)
> ComparePlot(IC1, IC2, y, withCall = TRUE)
comparePlot(obj1 = new("IC", CallL2Fam = GammaFamily(scale = 1, 
    shape = 1, trafo = c(1, 0, 0, 1)), modifyIC = function(L2Fam, IC, withMakeIC=FALSE, ...){ optIC(L2Fam, asCov()) }, 
    name = "Classical optimal influence curve for Gamma family", 
    Curve = new("EuclRandVarList", .Data = list(new("EuclRandVariable", 
        Map = list(function (x) 
        {
            f1 <- function (x) 
            {
                f1 <- function (x) 
                {
                  y <- 0 * x
                  inS <- liesInSupport(distr.0, x, checkFin = TRUE)
                  y[inS] <- (x[inS]/c(scale = 1) - c(shape = 1))/c(scale = 1)
                  return(y)
                }
                2.55054609673043 %*% f1(x)
            }
            f2 <- function (x) 
            {
                y <- 0 * x
                inS <- liesInSupport(distr.0, x, checkFin = TRUE)
                y[inS] <- log(x[inS]/c(scale = 1)) - digamma(c(shape = 1))
                return(y)
            }
            f1(x) + -1.55054609673043 %*% f2(x)
        }, function (x) 
        {
            f1 <- function (x) 
            {
                f1 <- function (x) 
                {
                  y <- 0 * x
                  inS <- liesInSupport(distr.0, x, checkFin = TRUE)
                  y[inS] <- (x[inS]/c(scale = 1) - c(shape = 1))/c(scale = 1)
                  return(y)
                }
                -1.55054609673043 %*% f1(x)
            }
            f2 <- function (x) 
            {
                y <- 0 * x
                inS <- liesInSupport(distr.0, x, checkFin = TRUE)
                y[inS] <- log(x[inS]/c(scale = 1)) - digamma(c(shape = 1))
                return(y)
            }
            f1(x) + 1.55054609673043 %*% f2(x)
        }), Domain = new("Reals", dimension = 1, name = "Real Space"), 
        Range = new("Reals", dimension = 1, name = "Real Space")))), 
    Risks = list(asCov = c(2.55054609673043, -1.55054609673043, 
    -1.55054609673043, 1.55054609673043), trAsCov = 4.10109219346086), 
    Infos = c("optIC", "optimal IC in sense of Cramer-Rao bound"
    )), obj2 = new("IC", CallL2Fam = GammaFamily(scale = 1, shape = 1, 
    trafo = matrix(c(1, 0, 0, 1), ncol = 2, dimnames = list(c("scale", 
    "shape"), c("scale", "shape")))), modifyIC = function(L2Fam, IC, withMakeIC = FALSE, ...)
                                 return(makeIC(IC,L2Fam, ...)), 
    name = "square integrable (partial) influence curve", Curve = new("EuclRandVarList", 
        .Data = list(new("EuclRandVariable", Map = list(function (x) 
        {
            f1 <- function (x) 
            {
                f1 <- function (x) 
                {
                  f1 <- function (x) 
                  {
                    f1 <- function (x) 
                    sin(x)
                    1 %*% f1(x)
                  }
                  f1(x) - 0.500000265830412
                }
                c(scale = -3.41853959532626) %*% f1(x)
            }
            f2 <- function (x) 
            {
                f1 <- function (x) 
                {
                  f1 <- function (x) 
                  {
                    numeric(1)
                  }
                  f2 <- function (x) 
                  x^2
                  f1(x) + 1 %*% f2(x)
                }
                f1(x) - 1.99995915034328
            }
            f1(x) + c(scale = 0.250035802973725) %*% f2(x)
        }, function (x) 
        {
            f1 <- function (x) 
            {
                f1 <- function (x) 
                {
                  f1 <- function (x) 
                  {
                    f1 <- function (x) 
                    sin(x)
                    1 %*% f1(x)
                  }
                  f1(x) - 0.500000265830412
                }
                c(shape = 4.55770564375545) %*% f1(x)
            }
            f2 <- function (x) 
            {
                f1 <- function (x) 
                {
                  f1 <- function (x) 
                  {
                    numeric(1)
                  }
                  f2 <- function (x) 
                  x^2
                  f1(x) + 1 %*% f2(x)
                }
                f1(x) - 1.99995915034328
            }
            f1(x) + c(shape = -7.66202724840538e-06) %*% f2(x)
        }), Domain = new("Reals", dimension = 1, name = "Real Space"), 
            Range = new("Reals", dimension = 1, name = "Real Space")))), 
    Risks = list(), Infos = c("IC<-", "generated by affine linear trafo to enforce consistency"
    )), MBR.fac = 2, MBRB = NA, adj = 0.5, adj.lbs = c(0, 0), 
    alpha.trsp = 50, bmar = par("mar")[1], bty = "o", cex = 1.5, 
    cex.inner = 0.8, cex.lab = 1, cex.lbs = 1, cex.main = 1.5, 
    cex.npts = 2, cex.pts = 1, col = "blue", col.MBR = par("col"), 
    col.inner = par("col.main"), col.lab = "black", col.lbs = par("col"), 
    col.main = "black", col.npts = addAlphTrsp2col(rgb(0, 255, 
        0, maxColorValue = 255), substitute(50)), col.pts = c(1, 
        2, 3, 4), data = y, forceSameModel = FALSE, inner = TRUE, 
    jitter.fac = 1, legend1 = "IC1", legend2 = "IC2", legend.bg = "white", 
    legend.cex = 0.8, legend.location = "bottomright", lty = "solid", 
    lty.MBR = "dashed", lwd = par("lwd"), lwd.MBR = 0.8, main = FALSE, 
    mfColRow = TRUE, pch.npts = 20, pch.pts = 19, return.Order = FALSE, 
    scaleN = 9, scaleX = FALSE, scaleY = FALSE, scaleY.fct = function (q, 
        mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pnorm, q, mean, sd, lower.tail, log.p), scaleY.inv = function (p, 
        mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qnorm, p, mean, sd, lower.tail, log.p), sub = FALSE, 
    tmar = par("mar")[3], with.automatic.grid = TRUE, with.lab = FALSE, 
    with.legend = FALSE, withMBR = FALSE, withSubst = TRUE, withSweave = getdistrOption("withSweave"))
> 
> 
> 
> cleanEx()
> nameEx("ContIC-class")
> ### * ContIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContIC-class
> ### Title: Influence curve of contamination type
> ### Aliases: ContIC-class CallL2Fam<-,ContIC-method cent cent,ContIC-method
> ###   cent<- cent<-,ContIC-method clip,ContIC-method clip<-
> ###   clip<-,ContIC-method lowerCase<- lowerCase<-,ContIC-method stand<-
> ###   stand<-,ContIC-method neighbor,ContIC-method
> ###   generateIC,ContNeighborhood,L2ParamFamily-method show,ContIC-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> IC1 <- new("ContIC")
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("ContIC")
> ### * ContIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContIC
> ### Title: Generating function for ContIC-class
> ### Aliases: ContIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- ContIC()
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("ContNeighborhood-class")
> ### * ContNeighborhood-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContNeighborhood-class
> ### Title: Contamination Neighborhood
> ### Aliases: ContNeighborhood-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("ContNeighborhood")
An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("ContNeighborhood")
> ### * ContNeighborhood
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContNeighborhood
> ### Title: Generating function for ContNeighborhood-class
> ### Aliases: ContNeighborhood
> ### Keywords: models
> 
> ### ** Examples
> 
> ContNeighborhood()
An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(radius = 0){ 
+     new("ContNeighborhood", radius = radius) 
+ }
function (radius = 0) 
{
    new("ContNeighborhood", radius = radius)
}
> 
> 
> 
> cleanEx()
> nameEx("FixRobModel-class")
> ### * FixRobModel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FixRobModel-class
> ### Title: Robust model with fixed (unconditional) neighborhood
> ### Aliases: FixRobModel-class neighbor<-,FixRobModel-method
> ###   show,FixRobModel-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("FixRobModel")
An object of class "FixRobModel" 
###### center:	An object of class "ParamFamily"
### name:	parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0

###### neighborhood:	An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("FixRobModel")
> ### * FixRobModel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FixRobModel
> ### Title: Generating function for FixRobModel-class
> ### Aliases: FixRobModel
> ### Keywords: models
> 
> ### ** Examples
> 
> (M1 <- FixRobModel())
An object of class "FixRobModel" 
###### center:	An object of class "ParamFamily"
### name:	parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location
main:	0

###### neighborhood:	An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(center = ParamFamily(), neighbor = ContNeighborhood()){
+     new("FixRobModel", center = center, neighbor = neighbor)
+ }
function (center = ParamFamily(), neighbor = ContNeighborhood()) 
{
    new("FixRobModel", center = center, neighbor = neighbor)
}
> 
> 
> 
> cleanEx()
> nameEx("HampIC-class")
> ### * HampIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HampIC-class
> ### Title: Influence curve of Hampel type
> ### Aliases: HampIC-class lowerCase lowerCase,HampIC-method neighborRadius
> ###   neighborRadius,ANY-method neighborRadius,HampIC-method
> ###   neighborRadius<- neighborRadius<-,HampIC-method stand
> ###   stand,HampIC-method weight,HampIC-method biastype,HampIC-method
> ###   normtype,HampIC-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> IC1 <- new("HampIC")
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("HampelWeight-class")
> ### * HampelWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HampelWeight-class
> ### Title: Robust Weight classes for weights of Hampel type
> ### Aliases: HampelWeight-class cent,HampelWeight-method
> ###   cent<-,HampelWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("HampelWeight")
An object of class "HampelWeight"
Slot "cent":
[1] 0

Slot "stand":
     [,1]
[1,]    1

Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function(x) 1
<bytecode: 0x0d17de70>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("IC-class")
> ### * IC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IC-class
> ### Title: Influence curve
> ### Aliases: IC-class CallL2Fam CallL2Fam,IC-method CallL2Fam<-
> ###   CallL2Fam<-,IC-method modifyIC modifyIC,IC-method
> ###   evalIC,IC,numeric-method evalIC,IC,matrix-method show,IC-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("IC")
> ### * IC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IC
> ### Title: Generating function for IC-class
> ### Aliases: IC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- IC()
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("InfRobModel-class")
> ### * InfRobModel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfRobModel-class
> ### Title: Robust model with infinitesimal (unconditional) neighborhood
> ### Aliases: InfRobModel-class neighbor<-,InfRobModel-method
> ###   show,InfRobModel-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("InfRobModel")
An object of class "InfRobModel" 
###### center:	An object of class "L2ParamFamily"
### name:	L_2 differentiable parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0

###### neighborhood:	An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("InfRobModel")
> ### * InfRobModel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfRobModel
> ### Title: Generating function for InfRobModel-class
> ### Aliases: InfRobModel
> ### Keywords: models
> 
> ### ** Examples
> 
> (M1 <- InfRobModel())
An object of class "InfRobModel" 
###### center:	An object of class "L2ParamFamily"
### name:	L_2 differentiable parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location
main:	0

###### neighborhood:	An object of class "ContNeighborhood" 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(center = L2ParamFamily(), neighbor = ContNeighborhood()){
+     new("InfRobModel", center = center, neighbor = neighbor)
+ }
function (center = L2ParamFamily(), neighbor = ContNeighborhood()) 
{
    new("InfRobModel", center = center, neighbor = neighbor)
}
> 
> 
> 
> cleanEx()
> nameEx("InfluenceCurve-class")
> ### * InfluenceCurve-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfluenceCurve-class
> ### Title: Influence curve
> ### Aliases: InfluenceCurve-class addInfo<- addInfo<-,InfluenceCurve-method
> ###   addRisk<- addRisk<-,InfluenceCurve-method Curve
> ###   Curve,InfluenceCurve-method Domain,InfluenceCurve-method Infos
> ###   Infos,InfluenceCurve-method Infos<- Infos<-,InfluenceCurve-method
> ###   Map,InfluenceCurve-method name,InfluenceCurve-method
> ###   name<-,InfluenceCurve-method Range,InfluenceCurve-method Risks
> ###   Risks,InfluenceCurve-method Risks<- Risks<-,InfluenceCurve-method
> ###   show,InfluenceCurve-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> new("InfluenceCurve")
An object of class "InfluenceCurve" 
### name:	  

### 'Curve':	An object of class "EuclRandVarList" 
Domain:	NULL
[[1]]
length of Map:	 1 
Range:	Euclidean Space with dimension 1 

### Infos:
<0 x 0 matrix>
> 
> 
> 
> cleanEx()
> nameEx("InfluenceCurve")
> ### * InfluenceCurve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfluenceCurve
> ### Title: Generating function for InfluenceCurve-class
> ### Aliases: InfluenceCurve
> ### Keywords: robust
> 
> ### ** Examples
> 
> InfluenceCurve()
An object of class "InfluenceCurve" 
### name:	 influence curve 

### 'Curve':	An object of class "EuclRandVarList" 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Euclidean Space with dimension 1 

### Infos:
     method message
> 
> ## The function is currently defined as
> InfluenceCurve <- function(name, Curve = EuclRandVarList(EuclRandVariable(Domain = Reals())), 
+                            Risks, Infos){
+     if(missing(name))
+         name <- "influence curve"
+     if(missing(Risks))
+         Risks <- list()
+     if(missing(Infos))
+         Infos <- matrix(c(character(0),character(0)), ncol=2,
+                      dimnames=list(character(0), c("method", "message")))
+     
+     return(new("InfluenceCurve", name = name, Curve = Curve, 
+                Risks = Risks, Infos = Infos))
+ }
> 
> 
> 
> cleanEx()
> nameEx("InfoPlotWrapper")
> ### * InfoPlotWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfoPlot
> ### Title: Wrapper function for information plot method
> ### Aliases: InfoPlot
> 
> ### ** Examples
> 
> # Gamma
> fam  <-  GammaFamily()
> IC <- optIC(model = fam, risk = asCov())
> Y <- distribution(fam)
> data  <-  r(Y)(500)
> InfoPlot(IC, data, withCall = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("MEstimate-class")
> ### * MEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MEstimate-class
> ### Title: MEstimate-class.
> ### Aliases: MEstimate-class Mroot Mroot,MEstimate-method
> ###   show,MEstimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("MEstimate")
Evaluations of Asymptotically linear estimate:
----------------------------------------------
An object of class "MEstimate" 
generated by call
  `{}`()
estimate:
numeric(0)
asymptotic bias:
NULL
value of M equation:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("PlotICWrapper")
> ### * PlotICWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PlotIC
> ### Title: Wrapper function for plot method for IC
> ### Aliases: PlotIC
> 
> ### ** Examples
> 
> # Gamma
> fam <- GammaFamily()
> rfam <- InfRobModel(fam, ContNeighborhood(0.5))
> IC <- optIC(model = fam, risk = asCov())
> Y <- distribution(fam)
> y <- r(Y)(1000)
> PlotIC(IC, y, withCall = FALSE)
> 
> 
> 
> cleanEx()
> nameEx("RobAStBaseMASK")
> ### * RobAStBaseMASK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBaseMASK
> ### Title: Masking of/by other functions in package "RobAStBase"
> ### Aliases: RobAStBaseMASK MASKING
> ### Keywords: programming distribution documentation
> 
> ### ** Examples
> 
> RobAStBaseMASK()
######################################################################
#  On masking of and by other functions in package "RobAStBase"       
######################################################################

Attention:

*** intentional masking: ***

To be able to use the same symbol for objects of S4-classes 'kStepEstimate',
respectively of classes 'ContIC','TotalVarIC','BoundedWeight',
we intentionally mask the following function[s] --- however this/these 
function[s] may still be used in exactly the same way as before 
masking:

+start()    (package "stats")
+clip()    (package "graphics")
 
 
> 
> 
> 
> cleanEx()
> nameEx("RobAStBaseOptions")
> ### * RobAStBaseOptions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBaseOptions
> ### Title: Function to change the global variables of the package
> ###   'RobAStBase'
> ### Aliases: RobAStBaseOptions getRobAStBaseOption kStepUseLast
> ###   modifyICwarn withUpdateInKer IC.UpdateInKer all.verbose withICList
> ###   withPICList modifyICwarn
> ### Keywords: misc robust
> 
> ### ** Examples
> 
> RobAStBaseOptions()
$kStepUseLast
[1] FALSE

$withUpdateInKer
[1] FALSE

$IC.UpdateInKer
NULL

$all.verbose
[1] FALSE

$withICList
[1] FALSE

$withPICList
[1] FALSE

$modifyICwarn
[1] TRUE

> RobAStBaseOptions("kStepUseLast")
$kStepUseLast
[1] FALSE

> RobAStBaseOptions("kStepUseLast" = TRUE)
> # or
> RobAStBaseOptions(kStepUseLast = 1e-6)
> getRobAStBaseOption("kStepUseLast")
[1] 1e-06
> 
> 
> 
> cleanEx()
> nameEx("RobWeight-class")
> ### * RobWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobWeight-class
> ### Title: Robust Weight classes
> ### Aliases: RobWeight-class name,RobWeight-method name<-,RobWeight-method
> ###   weight weight,RobWeight-method weight<- weight<--methods
> ###   weight<-,RobWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("RobWeight")
An object of class "RobWeight"
Slot "name":
[1] "some weight"

Slot "weight":
function(x) 1
<bytecode: 0x0d1d7110>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("TotalVarIC-class")
> ### * TotalVarIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarIC-class
> ### Title: Influence curve of total variation type
> ### Aliases: TotalVarIC-class CallL2Fam<-,TotalVarIC-method clipLo
> ###   clip,TotalVarIC-method clipLo,TotalVarIC-method clipLo<-
> ###   clipLo<-,TotalVarIC-method clipUp clipUp,TotalVarIC-method clipUp<-
> ###   clipUp<-,TotalVarIC-method lowerCase<-,TotalVarIC-method
> ###   neighbor,TotalVarIC-method show,TotalVarIC-method
> ###   stand<-,TotalVarIC-method
> ###   generateIC,TotalVarNeighborhood,L2ParamFamily-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> IC1 <- new("TotalVarIC")
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("TotalVarIC")
> ### * TotalVarIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarIC
> ### Title: Generating function for TotalVarIC-class
> ### Aliases: TotalVarIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- TotalVarIC()
> plot(IC1)
> 
> 
> 
> cleanEx()
> nameEx("TotalVarNeighborhood-class")
> ### * TotalVarNeighborhood-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarNeighborhood-class
> ### Title: Total variation neighborhood
> ### Aliases: TotalVarNeighborhood-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("TotalVarNeighborhood")
An object of class "TotalVarNeighborhood" 
type:	 (uncond.) total variation neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("TotalVarNeighborhood")
> ### * TotalVarNeighborhood
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarNeighborhood
> ### Title: Generating function for TotalVarNeighborhood-class
> ### Aliases: TotalVarNeighborhood
> ### Keywords: models
> 
> ### ** Examples
> 
> TotalVarNeighborhood()
An object of class "TotalVarNeighborhood" 
type:	 (uncond.) total variation neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(radius = 0){ 
+     new("TotalVarNeighborhood", radius = radius) 
+ }
function (radius = 0) 
{
    new("TotalVarNeighborhood", radius = radius)
}
> 
> 
> 
> cleanEx()
> nameEx("biastype-methods")
> ### * biastype-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: biastype-methods
> ### Title: Methods for Function biastype in Package 'RobAStBase'
> ### Aliases: biastype,interpolRisk-method biastype
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> biastype(myrisk)
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> 
> 
> 
> cleanEx()
> nameEx("checkIC")
> ### * checkIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkIC
> ### Title: Generic Function for Checking ICs
> ### Aliases: checkIC checkIC,IC,missing-method
> ###   checkIC,IC,L2ParamFamily-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> checkIC(IC1)
precision of centering:	 0 
precision of Fisher consistency:
              [,1]
[1,] -5.794001e-06
precision of Fisher consistency - relative error [%]:
              [,1]
[1,] -0.0005794001
maximum deviation 
     5.794001e-06 
> 
> 
> 
> cleanEx()
> nameEx("comparePlot")
> ### * comparePlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparePlot-methods
> ### Title: Compare - Plots
> ### Aliases: comparePlot comparePlot-methods comparePlot,IC,IC-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> if(require(ROptEst)){
+ 
+ N0 <- NormLocationScaleFamily(mean=0, sd=1) 
+ N0.Rob1 <- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))
+ 
+ IC1 <- optIC(model = N0, risk = asCov())
+ IC2 <- optIC(model = N0.Rob1, risk = asMSE())
+ 
+ comparePlot(IC1,IC2)
+ 
+ set.seed(12); data <- r(N0)(20)
+ comparePlot(IC1, IC2, data=data, with.lab = TRUE,
+             which.lbs = c(1:4,15:20),
+             which.Order = 1:6,
+             return.Order = TRUE)
+ 
+ 
+ ## don't test to reduce check time on CRAN
+ ## No test: 
+ ## selection of subpanels for plotting
+ par(mfrow=c(1,1))
+ comparePlot(IC1, IC2 ,mfColRow = FALSE, to.draw.arg=c("mean"),
+             panel.first= grid(),ylim=c(-4,4),xlim=c(-6,6))
+ ## matrix-valued ylim
+ comparePlot(IC1, IC2, panel.first= grid(),ylim=c(-4,4,0,4),xlim=c(-6,6))
+ 
+ x <- c(data,-12,10)
+ comparePlot(IC1, IC2, data=x, which.Order=10,
+             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ 
+ Y <- Chisq(df=1)* DiscreteDistribution(c(-1,1))
+ comparePlot(IC1, IC2, data=x, which.Order=10,
+             scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
+             scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q.l(Y),
+             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ comparePlot(IC1, IC2, data=x, which.Order=10,
+             scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
+             scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q.l(Y),
+             x.ticks = c(-Inf, -10, -1,0,1,10,Inf),
+             y.ticks = c(-Inf, -5, -1,0,1,5,Inf),
+             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ 
+ ## with use of trafo-matrix:
+ G <- GammaFamily(scale = 1, shape = 2)
+ ## explicitely transforming to
+ ## MASS parametrization:
+ mtrafo <- function(x){
+      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
+ G2 <- G
+ trafo(G2) <- mtrafo
+ G2
+ G2.Rob1 <- InfRobModel(center = G2, neighbor = ContNeighborhood(radius = 0.5))
+ system.time(IC1 <- optIC(model = G2, risk = asCov()))
+ system.time(IC2 <- optIC(model = G2.Rob1, risk = asMSE()))
+ system.time(IC2.i <- optIC(model = G2.Rob1, risk = asMSE(normtype=InfoNorm())))
+ system.time(IC2.s <- optIC(model = G2.Rob1, risk = asMSE(normtype=SelfNorm())))
+ 
+ comparePlot(IC1,IC2, IC2.i, IC2.s)
+ ## End(No test)
+ 
+ }
Loading required package: ROptEst
maximum iterations reached!
 achieved precision:	 3.02372e-05 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching 'package:ROptEst'

> nameEx("cutoff-class")
> ### * cutoff-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutoff-class
> ### Title: Cutoff class for distance-distance plots
> ### Aliases: cutoff-class cutoff.quantile<-,cutoff-method cutoff.quantile<-
> ###   cutoff.quantile,cutoff-method cutoff.quantile name,cutoff-method
> ###   fct,cutoff-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> cutoff()
An object of class "cutoff"
Slot "name":
[1] "empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    quantile(slot(norm, "fct")(data), cutoff.quantile)
}
<environment: 0x092c8de0>

Slot "cutoff.quantile":
[1] 0.95

> 
> 
> 
> cleanEx()
> nameEx("cutoff")
> ### * cutoff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutoff
> ### Title: Generating function(s) for class 'cutoff'
> ### Aliases: cutoff cutoff.sememp cutoff.chisq cutoff.quant
> ### Keywords: hplot
> 
> ### ** Examples
> 
> cutoff()
An object of class "cutoff"
Slot "name":
[1] "empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    quantile(slot(norm, "fct")(data), cutoff.quantile)
}
<environment: 0x09184510>

Slot "cutoff.quantile":
[1] 0.95

> cutoff.sememp()
An object of class "cutoff"
Slot "name":
[1] "semi-empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    {
        n.05 <- chol(QF)
        N0 <- matrix(rnorm(nsim * nrow(QF)), ncol = ncol(QF))
        N0 <- N0 %*% n.05
        quantile((rowSums(N0^2))^0.5, 0.95)
    }
}
<environment: 0x08f636d0>

Slot "cutoff.quantile":
[1] 0.95

> cutoff.chisq()
An object of class "cutoff"
Slot "name":
[1] "chisq"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    {
        dim = nrow(as.matrix(data))
        qchisq(df = dim, 0.95)^0.5
    }
}
<environment: 0x07f676e0>

Slot "cutoff.quantile":
[1] 0.95

> 
> 
> 
> cleanEx()
> nameEx("ddPlot-methods")
> ### * ddPlot-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ddPlot-methods
> ### Title: Methods for Function ddPlot in Package 'RobAStBase'
> ### Aliases: ddPlot ddPlot-methods ddPlot,matrix-method
> ###   ddPlot,numeric-method ddPlot,data.frame-method
> ### Keywords: methods hplot
> 
> ### ** Examples
> 
> MX <- matrix(rnorm(1500),nrow=6)
> QM <- matrix(rnorm(36),nrow=6); QM <- QM %*% t(QM)
> ddPlot(data=MX, dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)))
> 
> 
> 
> cleanEx()
> nameEx("getRiskFctBV-methods")
> ### * getRiskFctBV-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getRiskFctBV-methods
> ### Title: Methods for Function getRiskFctBV in Package 'RobAStBase'
> ### Aliases: getRiskFctBV getRiskFctBV-methods
> ###   getRiskFctBV,asGRisk,ANY-method getRiskFctBV,asMSE,ANY-method
> ###   getRiskFctBV,interpolRisk,ANY-method
> ###   getRiskFctBV,asSemivar,onesidedBias-method
> ###   getRiskFctBV,asSemivar,asymmetricBias-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- asMSE()
> getRiskFctBV(myrisk)
function(bias, var)  return(bias^2+var)
<environment: 0x153730a0>
> 
> 
> 
> cleanEx()
> nameEx("infoPlot")
> ### * infoPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: infoPlot
> ### Title: Plot absolute and relative information
> ### Aliases: infoPlot infoPlot-methods infoPlot,IC-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> N <- NormLocationScaleFamily(mean=0, sd=1) 
> IC1 <- optIC(model = N, risk = asCov())
> infoPlot(IC1)
> 
> ## don't run to reduce check time on CRAN
> ## No test: 
> ## selection of subpanels for plotting
> par(mfrow=c(1,2))
> infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"))
> infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"), log="y")
> 
> infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
+               panel.first= grid(), ylim = c(0,4), xlim = c(-6,6))
> infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
+               panel.first= grid(), ylim = c(0,4,-3,3), xlim = c(-6,6))
> 
> par(mfrow=c(1,3))
> infoPlot(IC1, mfColRow = FALSE, panel.first= grid(),
+          ylim = c(0,4,0,.3,0,.8), xlim=c(-6,6))
> par(mfrow=c(1,1))
> 
> data <- r(N)(20)
> par(mfrow=c(1,3))
> infoPlot(IC1, data=data, mfColRow = FALSE, panel.first= grid(),
+          with.lab = TRUE, cex.pts=2,
+          which.lbs = c(1:4,15:20), which.Order = 1:6,
+          return.Order = TRUE)
$sel
$sel$data
[1]  1.5952808  1.1249309  0.9438362 -0.8356286  0.8212212 -0.6264538

$sel$y
[1] 3.1416159 1.2830881 0.8938065 0.7210346 0.7009074 0.4847253

$sel$ind
[1]  4 15 18  3 19  1

$sel$ind1
 [1]  1  2  3  4 15 16 17 18 19 20

$sel$data.ns
 [1]  0.18364332  0.32950777 -0.82046838  0.48742905  0.73832471  0.57578135
 [7] -0.30538839  1.51178117  0.38984324 -0.62124058 -2.21469989 -0.04493361
[13] -0.01619026  0.59390132

$sel$y.ns
 [1] 0.2671468 0.3072348 0.6998731 0.3829054 0.5968516 0.4432392 0.2988055
 [8] 2.6985985 0.3317632 0.4802073 8.7169480 0.2510105 0.2501311 0.4574620

$sel$ind.ns
 [1]  2  5  6  7  8  9 10 11 12 13 14 16 17 20


$sel.C
$sel.C$data
[1]  1.5952808  1.1249309  0.9438362 -0.8356286  0.8212212 -0.6264538

$sel.C$y
[1] 3.1416159 1.2830881 0.8938065 0.7210346 0.7009074 0.4847253

$sel.C$ind
[1]  4 15 18  3 19  1

$sel.C$ind1
 [1]  1  2  3  4 15 16 17 18 19 20

$sel.C$data.ns
 [1]  0.18364332  0.32950777 -0.82046838  0.48742905  0.73832471  0.57578135
 [7] -0.30538839  1.51178117  0.38984324 -0.62124058 -2.21469989 -0.04493361
[13] -0.01619026  0.59390132

$sel.C$y.ns
 [1] 0.2671468 0.3072348 0.6998731 0.3829054 0.5968516 0.4432392 0.2988055
 [8] 2.6985985 0.3317632 0.4802073 8.7169480 0.2510105 0.2501311 0.4574620

$sel.C$ind.ns
 [1]  2  5  6  7  8  9 10 11 12 13 14 16 17 20


> infoPlot(IC1, data=data[1:10], mfColRow = FALSE, panel.first= grid(),
+          with.lab = TRUE, cex.pts=0.7)
> par(mfrow=c(1,1))
> 
> ICr <- makeIC(list(function(x)sign(x),function(x)sign(abs(x)-qnorm(.75))),N)
> data <- r(N)(600)
> data.c <- c(data, 1000*data[1:30])
> par(mfrow=c(3,1))
> infoPlot(ICr, data=data.c, tmar=c(4.1,0,0), bmar=c(0,0,4.1),
+          xaxt=c("n","n","s"), mfColRow = FALSE, panel.first= grid(),
+          cex.pts=c(.9,.9), alpha.trsp=20, lwd=2, lwdI=1.5, col=3,
+          col.pts=c(3,2), colI=2, pch.pts=c(20,20), inner=FALSE,
+          scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
+          scaleY=TRUE, scaleY.fct=function(x) pchisq(x,df=1),
+          scaleY.inv=function(x)qchisq(x,df=1),legend.cex = 1.0)
> 
> ## End(No test)
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("internals_ddPlot")
> ### * internals_ddPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: internals_for_RobAStBase_ddPlot
> ### Title: Internal / Helper functions of package RobAStBase for ddPlot
> ### Aliases: internals_for_RobAStBase_ddPlot .ddPlot.MatNtNtCoCo
> ### Keywords: internal hplot
> 
> ### ** Examples
> 
> MX <- matrix(rnorm(1500),nrow=6)
> QM <- matrix(rnorm(36),nrow=6); QM <- QM %*% t(QM)
> RobAStBase:::.ddPlot.MatNtNtCoCo(data=MX, 
+         dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)),
+         xlab="Norm.x",ylab="Norm.y", cex.idn = 1.3, offset=0,
+         lwd=2, lwd.cutoff=4, lty=2, col.cutoff =2, col.idn="green",
+         col = "blue", adj=0.4, pos=4,id.n = sample(1:200,size=100),
+         lab.pts=letters,log="x", main="GA", sub="NO",cex.sub=0.2)
Warning in (function (which = "plot", lty = "solid", ...)  :
  "log" is not a graphical parameter
> 
> 
> 
> cleanEx()
> nameEx("interpolRisk-class")
> ### * interpolRisk-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interpolRisk-class
> ### Title: Interpolated Risks
> ### Aliases: interpolRisk-class OMSRRisk-class RMXRRisk-class MBRRisk-class
> ###   OMSRRisk RMXRRisk MBRRisk
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("OMSRRisk")
An object of class "OMSRRisk" 
risk type:	 .OMSE 
> OMSRRisk()
An object of class "OMSRRisk" 
risk type:	 .OMSE 
> RMXRRisk()
An object of class "RMXRRisk" 
risk type:	 .RMXE 
> MBRRisk()
An object of class "MBRRisk" 
risk type:	 .MBRE 
> myrisk <- MBRRisk(samplesize=100)
> samplesize(myrisk)
[1] 100
> samplesize(myrisk) <- 20
> 
> 
> 
> cleanEx()
> nameEx("kStepEstimator")
> ### * kStepEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kStepEstimator
> ### Title: Function for the computation of k-step estimates
> ### Aliases: kStepEstimator
> ### Keywords: univar robust
> 
> ### ** Examples
> 
> ## don't run to reduce check time on CRAN
> ## No test: 
> if(require(ROptEst)){
+ ## 1. generate a contaminated sample
+ ind <- rbinom(100, size=1, prob=0.05)
+ x <- rnorm(100, mean=0, sd=(1-ind) + ind*9)
+ 
+ ## 2. Kolmogorov(-Smirnov) minimum distance estimator
+ (est0 <- MDEstimator(x=x, NormLocationScaleFamily()))
+ 
+ ## 3. k-step estimation: radius known
+ N1 <- NormLocationScaleFamily(mean=estimate(est0)["mean"], sd=estimate(est0)["sd"])
+ N1.Rob <- InfRobModel(center = N1, neighbor = ContNeighborhood(radius = 0.5))
+ IC1 <- optIC(model = N1.Rob, risk = asMSE())
+ (est1 <- kStepEstimator(x, IC1, est0, steps = 3, withPIC = TRUE))
+ estimate(est1)
+ ksteps(est1)
+ pICList(est1)
+ start(est1)
+ attr(est1,"timings")
+ 
+ ## a transformed model
+ tfct <- function(x){
+     nms0 <- c("mean","sd")
+     nms  <- "comb"
+     fval0 <- x[1]+2*x[2]
+     names(fval0) <- nms
+     mat0 <- matrix(c(1,2), nrow = 1, dimnames = list(nms,nms0))
+     return(list(fval = fval0, mat = mat0))
+ }
+ 
+ N1.traf <- N1; trafo(N1.traf) <- tfct
+ N1R.traf <- N1.Rob; trafo(N1R.traf) <- tfct
+ IC1.traf <- optIC(model = N1R.traf, risk = asMSE())
+ (est0.traf <- MDEstimator(x, N1.traf))
+ (est1.traf <- kStepEstimator(x, IC1.traf, est0, steps = 3,
+                 withIC = TRUE, withPIC = TRUE, withUpdateInKer = FALSE))
+ (est1a.traf <- kStepEstimator(x, IC1.traf, est0, steps = 3,
+                 withIC = TRUE, withPIC = TRUE, withUpdateInKer = TRUE))
+ estimate(est1.traf)
+ ksteps(est1.traf)
+ pICList(est1.traf)
+ startval(est1.traf)
+ 
+ untransformed.estimate(est1.traf)
+ uksteps(est1.traf)
+ ICList(est1.traf)
+ ustartval(est1.traf)
+ 
+ estimate(est1a.traf)
+ ksteps(est1a.traf)
+ pICList(est1a.traf)
+ startval(est1a.traf)
+ 
+ untransformed.estimate(est1a.traf)
+ uksteps(est1a.traf)
+ ICList(est1a.traf)
+ ustartval(est1a.traf)
+ }
Loading required package: ROptEst
            [,1]
mean -0.05297991
sd    0.92479741
> ## End(No test)
> 
> 
> 
> cleanEx()

detaching 'package:ROptEst'

> nameEx("makeIC-methods")
> ### * makeIC-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeIC
> ### Title: Generic Function for making ICs consistent at a possibly
> ###   different model
> ### Aliases: makeIC makeIC-methods makeIC,IC,missing-method
> ###   makeIC,IC,L2ParamFamily-method makeIC,list,L2ParamFamily-method
> ###   makeIC,function,L2ParamFamily-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> ## default IC
> IC1 <- new("IC")
> 
> ## L2-differentiable parametric family
> B <- BinomFamily(13, 0.3)
> 
> ## check IC properties
> checkIC(IC1, B)
precision of centering:	 3.9 
precision of Fisher consistency:
     prob
prob   12
precision of Fisher consistency - relative error [%]:
     prob
prob 1200
maximum deviation 
               12 
> 
> ## make IC
> IC2 <- makeIC(IC1, B)
> 
> ## check IC properties
> checkIC(IC2)
precision of centering:	 2.813539e-17 
precision of Fisher consistency:
              prob
prob -1.110223e-16
precision of Fisher consistency - relative error [%]:
              prob
prob -1.110223e-14
maximum deviation 
                0 
> 
> ## slot modifyIC is filled in case of IC2
> IC3 <- modifyIC(IC2)(BinomFamily(13, 0.2), IC2)
> checkIC(IC3)
precision of centering:	 3.833034e-18 
precision of Fisher consistency:
     prob
prob    0
precision of Fisher consistency - relative error [%]:
     prob
prob    0
maximum deviation 
                0 
> ## identical to
> checkIC(IC3, BinomFamily(13, 0.2))
precision of centering:	 3.833034e-18 
precision of Fisher consistency:
     prob
prob    0
precision of Fisher consistency - relative error [%]:
     prob
prob    0
maximum deviation 
                0 
> 
> IC4 <- makeIC(sin, B)
> checkIC(IC4)
precision of centering:	 1.559677e-17 
precision of Fisher consistency:
             prob
prob 2.220446e-16
precision of Fisher consistency - relative error [%]:
             prob
prob 2.220446e-14
maximum deviation 
                0 
> 
> (IC5 <- makeIC(list(function(x)x^3), B, name="a try"))
An object of class "IC" 
### name:	 a try 
### L2-differentiable parametric family:	 Binomial family 

### 'Curve':	An object of class "EuclRandVarList" 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

### Infos:
     method message                                                  
[1,] "IC<-" "generated by affine linear trafo to enforce consistency"
> plot(IC5)
> checkIC(IC5)
precision of centering:	 2.735345e-17 
precision of Fisher consistency:
              prob
prob -1.110223e-16
precision of Fisher consistency - relative error [%]:
              prob
prob -1.110223e-14
maximum deviation 
                0 
> 
> ## don't run to reduce check time on CRAN
> ## No test: 
> N0 <- NormLocationScaleFamily()
> IC6 <- makeIC(list(sin,cos),N0)
> plot(IC6)
> checkIC(IC6)
precision of centering:	 0 -1.999988e-07 
precision of Fisher consistency:
              mean            sd
mean -1.110223e-16  0.000000e+00
sd    0.000000e+00 -5.593968e-06
precision of Fisher consistency - relative error [%]:
              mean            sd
mean -1.110223e-14           NaN
sd             NaN -0.0005593968
maximum deviation 
     5.593968e-06 
> 
> getRiskIC(IC6,risk=trAsCov())$trAsCov$value
[1] 1.718272
> getRiskIC(IC6,risk=asBias(),neighbor=ContNeighborhood())$asBias$value
[1] 2.648706
> ## End(No test)
> 
> 
> 
> 
> cleanEx()
> nameEx("normtype-methods")
> ### * normtype-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normtype-methods
> ### Title: Methods for Function normtype in Package 'RobAStBase'
> ### Aliases: normtype,interpolRisk-method normtype
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> normtype(myrisk)
An object of class "NormType"
Slot "name":
[1] "EuclideanNorm"

Slot "fct":
function(x){ 
    if(is.vector(x)) 
        return(abs(x))
    else 
        return(sqrt(colSums(x^2)))
}
<bytecode: 0x0e083878>
<environment: namespace:distrMod>

> 
> 
> 
> cleanEx()
> nameEx("optIC")
> ### * optIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optIC
> ### Title: Generic function for the computation of optimally robust ICs
> ### Aliases: optIC optIC-methods optIC,L2ParamFamily,asCov-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> B <- BinomFamily(size = 25, prob = 0.25) 
> 
> ## classical optimal IC
> IC0 <- optIC(model = B, risk = asCov())
> plot(IC0) # plot IC
> checkIC(IC0, B)
precision of centering:	 -2.112044e-17 
precision of Fisher consistency:
              prob
prob -2.220446e-16
precision of Fisher consistency - relative error [%]:
              prob
prob -2.220446e-14
maximum deviation 
                0 
> 
> 
> 
> cleanEx()
> nameEx("outlyingPlotIC")
> ### * outlyingPlotIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outlyingPlotIC
> ### Title: Function outlyingPlotIC in Package 'RobAStBase'
> ### Aliases: outlyingPlotIC
> ### Keywords: hplot
> 
> ### ** Examples
> 
> if(require(ROptEst)){
+ ## generates normal location and scale family with mean = -2 and sd = 3
+ N0 <- NormLocationScaleFamily()
+ N0.IC0 <- optIC(model = N0, risk = asCov())
+ N0.Rob1 <- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))
+ N0.IC1 <- optIC(model = N0.Rob1, risk = asMSE())
+ set.seed(123)
+ xn <- c(rnorm(100),rcauchy(20)+20)
+ outlyingPlotIC(xn, IC.x=N0.IC0)
+ outlyingPlotIC(xn, IC.x=N0.IC1)
+ 
+ ## example for usage with cutoff.quant()
+ classIC <- optIC(NormLocationScaleFamily(mean = 3.3, sd = 0.67),
+                   risk = asCov())
+ outlyingPlotIC(data = chem[-17], classIC, cex.pts = 3, jitter.fac = 1,
+                 cutoff.x = cutoff.quant(), tf.x =function(x)(x))
+ }
Loading required package: ROptEst
> 
> 
> 
> cleanEx()

detaching 'package:ROptEst'

> nameEx("plot-methods")
> ### * plot-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot-methods
> ### Title: Methods for Function plot in Package 'RobAStBase'
> ### Aliases: plot plot-methods plot,IC,missing-method
> ###   plot,IC,numeric-method
> ### Keywords: methods distribution
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> plot(IC1)
> plot(IC1, main = TRUE, panel.first= grid(),
+      col = "blue", cex.main = 2, cex.inner = 1)
> 
> ### selection of subpanels for plotting
> N <- NormLocationScaleFamily(mean=0, sd=1) 
> IC2 <- optIC(model = N, risk = asCov())
> par(mfrow=c(1,1))
> plot(IC2, main = TRUE, panel.first= grid(),
+      col = "blue", cex.main = 2, cex.inner = 0.6,
+      mfColRow = FALSE, to.draw.arg=c("sd"))
> 
> ## xlim and ylim arguments
> plot(IC2, main = TRUE, panel.first= grid(), 
+      ylim=c(-3,3), xlim=c(-2,3))
> plot(IC2, main = TRUE, panel.first= grid(), 
+      ylim=c(-3,3,-1,3), xlim=c(-2,3),
+      with.legend = TRUE)
> 
> data <- r(N)(30)
> plot(IC2, data, panel.first= grid(),
+      ylim = c(-3,3,-1,3), xlim=c(-2,3),
+      cex.pts = 3, pch.pts = 1:2, col.pts="green",
+      with.lab = TRUE, which.lbs = c(1:4,15:20),
+      which.Order = 1:6, return.Order = TRUE)
$obj
[1]  4 15 18  3 19  1

> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("qqplot")
> ### * qqplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qqplot
> ### Title: Methods for Function qqplot in Package 'RobAStBase'
> ### Aliases: qqplot qqplot-methods qqplot,ANY,RobModel-method
> ###   qqplot,ANY,InfRobModel-method qqplot,ANY,kStepEstimate-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> ## \donttest to reduce check time
> ## No test: 
> qqplot(rnorm(40, mean = 15, sd = sqrt(30)), Chisq(df=15))
> RobM <- InfRobModel(center = NormLocationFamily(mean=13,sd=sqrt(28)),
+                     neighbor = ContNeighborhood(radius = 0.4))
> 
> x <- rnorm(20, mean = 15, sd = sqrt(30))
> qqplot(x, RobM)
> qqplot(x, RobM, alpha.CI=0.9, add.points.CI=FALSE)
Warning in plot.window(...) :
  "add.points.CI" is not a graphical parameter
Warning in plot.xy(xy, type, ...) :
  "add.points.CI" is not a graphical parameter
Warning in axis(side = side, at = at, labels = labels, ...) :
  "add.points.CI" is not a graphical parameter
Warning in axis(side = side, at = at, labels = labels, ...) :
  "add.points.CI" is not a graphical parameter
Warning in box(...) : "add.points.CI" is not a graphical parameter
Warning in title(...) : "add.points.CI" is not a graphical parameter
> ## End(No test)
> ## further examples for ANY,kStepEstimator-method
> ## in example to roptest() in package ROptEst
> 
> 
> 
> cleanEx()
> nameEx("returnlevelplot")
> ### * returnlevelplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: returnlevelplot
> ### Title: Methods for Function returnlevelplot in Package 'RobAStBase'
> ### Aliases: returnlevelplot returnlevelplot-methods
> ###   returnlevelplot,ANY,RobModel-method
> ###   returnlevelplot,ANY,InfRobModel-method
> ###   returnlevelplot,ANY,kStepEstimate-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> returnlevelplot(rnorm(40, mean = 15, sd = sqrt(30)), Chisq(df=15))
> RobM <- InfRobModel(center = NormLocationFamily(mean=13,sd=sqrt(28)),
+                     neighbor = ContNeighborhood(radius = 0.4))
> ## No test: 
> ## \donttest to reduce check time
> x <- rnorm(20, mean = 15, sd = sqrt(30))
> returnlevelplot(x, RobM)
> returnlevelplot(x, RobM, alpha.CI=0.9, add.points.CI=FALSE)
Warning in plot.window(...) :
  "add.points.CI" is not a graphical parameter
Warning in plot.xy(xy, type, ...) :
  "add.points.CI" is not a graphical parameter
Warning in axis(side = side, at = at, labels = labels, ...) :
  "add.points.CI" is not a graphical parameter
Warning in axis(side = side, at = at, labels = labels, ...) :
  "add.points.CI" is not a graphical parameter
Warning in box(...) : "add.points.CI" is not a graphical parameter
Warning in title(...) : "add.points.CI" is not a graphical parameter
Warning in plot.xy(xy.coords(x, y), type = type, ...) :
  "add.points.CI" is not a graphical parameter
> ## End(No test)
> ## further examples for ANY,kStepEstimator-method
> ## in example to roptest() in package ROptEst
> 
> 
> 
> cleanEx()
> nameEx("samplesize-methods")
> ### * samplesize-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: samplesize-methods
> ### Title: Methods for Function samplesize in Package 'RobAStBase'
> ### Aliases: samplesize,interpolRisk-method samplesize
> ###   samplesize<-,interpolRisk-method samplesize<-
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> samplesize(myrisk)
[1] 100
> samplesize(myrisk) <- 20
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  190.35 2.93 360.61 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
