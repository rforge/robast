
R Under development (unstable) (2015-05-02 r68310) -- "Unsuffered Consequences"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "RobAStBase"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('RobAStBase')
Loading required package: rrcov
Loading required package: robustbase
Scalable Robust Estimators with High Breakdown Point (version 1.3-8)

Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for Start-Up Messages (version 0.9.1)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
Loading required package: SweaveListingUtils
:SweaveListingUtils>  Utilities for Sweave Together with
:SweaveListingUtils>  TeX 'listings' Package (version
:SweaveListingUtils>  0.7)
:SweaveListingUtils> 
:SweaveListingUtils>  NOTE: Support for this package
:SweaveListingUtils>  will stop soon.
:SweaveListingUtils> 
:SweaveListingUtils>  Package 'knitr' is providing the
:SweaveListingUtils>  same functionality in a better
:SweaveListingUtils>  way.
:SweaveListingUtils> 
:SweaveListingUtils>  Some functions from package 'base'
:SweaveListingUtils>  are intentionally masked ---see
:SweaveListingUtils>  SweaveListingMASK().
:SweaveListingUtils> 
:SweaveListingUtils>  Note that global options are
:SweaveListingUtils>  controlled by
:SweaveListingUtils>  SweaveListingoptions() ---c.f.
:SweaveListingUtils>  ?"SweaveListingoptions".
:SweaveListingUtils> 
:SweaveListingUtils>  For more information see
:SweaveListingUtils>  ?"SweaveListingUtils",
:SweaveListingUtils>  NEWS("SweaveListingUtils")
:SweaveListingUtils>  There is a vignette to this
:SweaveListingUtils>  package; try
:SweaveListingUtils>  vignette("ExampleSweaveListingUtils").


Attaching package: ‘SweaveListingUtils’

The following objects are masked from ‘package:base’:

    library, require

:distr>  Object Oriented Implementation of Distributions (version
:distr>  2.6)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: ‘distr’

The following objects are masked from ‘package:stats’:

    df, qqplot, sd

Loading required package: distrEx
:distrEx>  Extensions of Package 'distr' (version 2.6)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See
:distrEx>  distrExMASK().Note: Extreme value distribution
:distrEx>  functionality has been moved to
:distrEx> 
:distrEx>        package "RobExtremes". See distrExMOVED().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: ‘distrEx’

The following objects are masked from ‘package:stats’:

    IQR, mad, median, var

Loading required package: distrMod
Loading required package: RandVar
:RandVar>  Implementation of Random Variables (version 1.0)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object Oriented Implementation of Probability Models
:distrMod>  (version 2.6)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: ‘distrMod’

The following object is masked from ‘package:stats4’:

    confint

The following object is masked from ‘package:stats’:

    confint

The following object is masked from ‘package:base’:

    norm

:RobAStBase>  Robust Asymptotic Statistics (version 1.0)
:RobAStBase> 
:RobAStBase>  Some functions from pkg's 'stats' and 'graphics'
:RobAStBase>  are intentionally masked ---see RobAStBaseMASK().
:RobAStBase> 
:RobAStBase>  Note that global options are controlled by
:RobAStBase>  RobAStBaseoptions() ---c.f. ?"RobAStBaseoptions".
:RobAStBase> 
:RobAStBase>  For more information see ?"RobAStBase",
:RobAStBase>  NEWS("RobAStBase"), as well as
:RobAStBase>    http://robast.r-forge.r-project.org/


Attaching package: ‘RobAStBase’

The following object is masked from ‘package:graphics’:

    clip

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("0RobAStBase-package")
> ### * 0RobAStBase-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBase-package
> ### Title: Robust Asymptotic Statistics
> ### Aliases: RobAStBase-package RobAStBase
> ### Keywords: package
> 
> ### ** Examples
> 
> library(RobAStBase)
> 
> ## some L2 differentiable parametric family from package distrMod, e.g.
> B <- BinomFamily(size = 25, prob = 0.25) 
> 
> ## classical optimal IC
> IC0 <- optIC(model = B, risk = asCov())
> plot(IC0) # plot IC
NULL
> checkIC(IC0, B)
precision of centering:	 -7.3919e-18 
precision of Fisher consistency:
             prob
prob 2.220446e-16
precision of Fisher consistency - relativ error [%]:
             prob
prob 2.220446e-14
maximum deviation 
     2.220446e-16 
> 
> 
> 
> cleanEx()
> nameEx("ALEstimate-class")
> ### * ALEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ALEstimate-class
> ### Title: ALEstimate-class.
> ### Aliases: ALEstimate-class pIC pIC,ALEstimate-method asbias
> ###   asbias,ALEstimate-method show,ALEstimate-method
> ###   confint,ALEstimate,missing-method
> ###   confint,ALEstimate,symmetricBias-method
> ###   confint,ALEstimate,onesidedBias-method
> ###   confint,ALEstimate,asymmetricBias-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("ALEstimate")
Evaluations of Asymptotically linear estimate:
----------------------------------------------
An object of class “Estimate” 
generated by call
  `{}`()
estimate:
numeric(0)
asymptotic bias:
NULL
> 
> 
> 
> cleanEx()
> nameEx("BdStWeight-class")
> ### * BdStWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BdStWeight-class
> ### Title: Robust Weight classes for bounded, standardized weights
> ### Aliases: BdStWeight-class stand,BdStWeight-method
> ###   stand<-,BdStWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("BdStWeight")
An object of class "BdStWeight"
Slot "stand":
     [,1]
[1,]    1

Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function (x) 
1
<bytecode: 0x73c63c0>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("BoundedWeight-class")
> ### * BoundedWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BoundedWeight-class
> ### Title: Robust Weight classes for bounded weights
> ### Aliases: BoundedWeight-class clip,BoundedWeight-method
> ###   clip<-,BoundedWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("BoundedWeight")
An object of class "BoundedWeight"
Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function (x) 
1
<bytecode: 0x73a34a8>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("ComparePlotWrapper")
> ### * ComparePlotWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ComparePlot
> ### Title: Wrapper function for function comparePlot
> ### Aliases: ComparePlot
> 
> ### ** Examples
> 
> # Gamma
> fam <- GammaFamily()
> rfam <- InfRobModel(fam, ContNeighborhood(0.5))
> IC1 <- optIC(model = fam, risk = asCov())
> IC2 <- makeIC(list(function(x)sin(x),function(x)x^2), L2Fam = fam)
> Y <- distribution(fam)
> y <- r(Y)(100)
> ComparePlot(IC1, IC2, y, withCall = TRUE)
comparePlot(obj1 = IC1, obj2 = IC2, MBR.fac = 2, MBRB = NA, adj = 0.5, 
    alpha.trsp = 50, bmar = par("mar")[1], bty = "o", cex = 1.5, 
    cex.inner = 0.8, cex.lab = 1.5, cex.main = 1.5, cex.pts = 1, 
    col = "blue", col.MBR = par("col"), col.inner = par("col.main"), 
    col.lab = "black", col.main = "black", col.pts = c(1, 2, 
        3, 4), data = y, forceSameModel = FALSE, inner = TRUE, 
    jitter.fac = 1, legend.bg = "white", legend.cex = 0.8, legend.location = "bottomright", 
    lty.MBR = "dashed", lwd.MBR = 0.8, main = FALSE, mfColRow = TRUE, 
    pch.pts = 19, return.Order = FALSE, scaleN = 9, scaleX = FALSE, 
    scaleY = FALSE, scaleY.fct = function (q, mean = 0, sd = 1, 
        lower.tail = TRUE, log.p = FALSE) 
    .Call(C_pnorm, q, mean, sd, lower.tail, log.p), scaleY.inv = function (p, 
        mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 
    .Call(C_qnorm, p, mean, sd, lower.tail, log.p), sub = FALSE, 
    tmar = par("mar")[3], with.automatic.grid = TRUE, with.lab = FALSE, 
    with.legend = FALSE, withMBR = FALSE, withSubst = TRUE, withSweave = getdistrOption("withSweave"))
> 
> 
> 
> cleanEx()
> nameEx("ContIC-class")
> ### * ContIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContIC-class
> ### Title: Influence curve of contamination type
> ### Aliases: ContIC-class CallL2Fam<-,ContIC-method cent cent,ContIC-method
> ###   cent<- cent<-,ContIC-method clip,ContIC-method clip<-
> ###   clip<-,ContIC-method lowerCase<- lowerCase<-,ContIC-method stand<-
> ###   stand<-,ContIC-method neighbor,ContIC-method
> ###   generateIC,ContNeighborhood,L2ParamFamily-method show,ContIC-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> IC1 <- new("ContIC")
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("ContIC")
> ### * ContIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContIC
> ### Title: Generating function for ContIC-class
> ### Aliases: ContIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- ContIC()
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("ContNeighborhood-class")
> ### * ContNeighborhood-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContNeighborhood-class
> ### Title: Contamination Neighborhood
> ### Aliases: ContNeighborhood-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("ContNeighborhood")
An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("ContNeighborhood")
> ### * ContNeighborhood
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ContNeighborhood
> ### Title: Generating function for ContNeighborhood-class
> ### Aliases: ContNeighborhood
> ### Keywords: models
> 
> ### ** Examples
> 
> ContNeighborhood()
An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(radius = 0){ 
+     new("ContNeighborhood", radius = radius) 
+ }
function (radius = 0) 
{
    new("ContNeighborhood", radius = radius)
}
> 
> 
> 
> cleanEx()
> nameEx("FixRobModel-class")
> ### * FixRobModel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FixRobModel-class
> ### Title: Robust model with fixed (unconditional) neighborhood
> ### Aliases: FixRobModel-class neighbor<-,FixRobModel-method
> ###   show,FixRobModel-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("FixRobModel")
An object of class “FixRobModel” 
###### center:	An object of class "ParamFamily"
### name:	parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0

###### neighborhood:	An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("FixRobModel")
> ### * FixRobModel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FixRobModel
> ### Title: Generating function for FixRobModel-class
> ### Aliases: FixRobModel
> ### Keywords: models
> 
> ### ** Examples
> 
> (M1 <- FixRobModel())
An object of class “FixRobModel” 
###### center:	An object of class "ParamFamily"
### name:	parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location
main:	0

###### neighborhood:	An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(center = ParamFamily(), neighbor = ContNeighborhood()){
+     new("FixRobModel", center = center, neighbor = neighbor)
+ }
function (center = ParamFamily(), neighbor = ContNeighborhood()) 
{
    new("FixRobModel", center = center, neighbor = neighbor)
}
> 
> 
> 
> cleanEx()
> nameEx("HampIC-class")
> ### * HampIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HampIC-class
> ### Title: Influence curve of Hampel type
> ### Aliases: HampIC-class lowerCase lowerCase,HampIC-method neighborRadius
> ###   neighborRadius,HampIC-method neighborRadius<-
> ###   neighborRadius<-,HampIC-method stand stand,HampIC-method
> ###   weight,HampIC-method biastype,HampIC-method normtype,HampIC-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> IC1 <- new("HampIC")
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("HampelWeight-class")
> ### * HampelWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: HampelWeight-class
> ### Title: Robust Weight classes for weights of Hampel type
> ### Aliases: HampelWeight-class cent,HampelWeight-method
> ###   cent<-,HampelWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("HampelWeight")
An object of class "HampelWeight"
Slot "cent":
[1] 0

Slot "stand":
     [,1]
[1,]    1

Slot "clip":
[1] 1

Slot "name":
[1] "some weight"

Slot "weight":
function (x) 
1
<bytecode: 0x69bd9b8>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("IC-class")
> ### * IC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IC-class
> ### Title: Influence curve
> ### Aliases: IC-class CallL2Fam CallL2Fam,IC-method CallL2Fam<-
> ###   CallL2Fam<-,IC-method modifyIC modifyIC,IC-method
> ###   checkIC,IC,missing-method checkIC,IC,L2ParamFamily-method
> ###   evalIC,IC,numeric-method evalIC,IC,matrix-method show,IC-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("IC")
> ### * IC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IC
> ### Title: Generating function for IC-class
> ### Aliases: IC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- IC()
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("InfRobModel-class")
> ### * InfRobModel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfRobModel-class
> ### Title: Robust model with infinitesimal (unconditional) neighborhood
> ### Aliases: InfRobModel-class neighbor<-,InfRobModel-method
> ###   show,InfRobModel-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("InfRobModel")
An object of class “InfRobModel” 
###### center:	An object of class "L2ParamFamily"
### name:	L_2 differentiable parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0

###### neighborhood:	An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("InfRobModel")
> ### * InfRobModel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfRobModel
> ### Title: Generating function for InfRobModel-class
> ### Aliases: InfRobModel
> ### Keywords: models
> 
> ### ** Examples
> 
> (M1 <- InfRobModel())
An object of class “InfRobModel” 
###### center:	An object of class "L2ParamFamily"
### name:	L_2 differentiable parametric family of probability measures

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location
main:	0

###### neighborhood:	An object of class “ContNeighborhood” 
type:	 (uncond.) convex contamination neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(center = L2ParamFamily(), neighbor = ContNeighborhood()){
+     new("InfRobModel", center = center, neighbor = neighbor)
+ }
function (center = L2ParamFamily(), neighbor = ContNeighborhood()) 
{
    new("InfRobModel", center = center, neighbor = neighbor)
}
> 
> 
> 
> cleanEx()
> nameEx("InfluenceCurve-class")
> ### * InfluenceCurve-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfluenceCurve-class
> ### Title: Influence curve
> ### Aliases: InfluenceCurve-class addInfo<- addInfo<-,InfluenceCurve-method
> ###   addRisk<- addRisk<-,InfluenceCurve-method Curve
> ###   Curve,InfluenceCurve-method Domain,InfluenceCurve-method Infos
> ###   Infos,InfluenceCurve-method Infos<- Infos<-,InfluenceCurve-method
> ###   Map,InfluenceCurve-method name,InfluenceCurve-method
> ###   name<-,InfluenceCurve-method Range,InfluenceCurve-method Risks
> ###   Risks,InfluenceCurve-method Risks<- Risks<-,InfluenceCurve-method
> ###   show,InfluenceCurve-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> new("InfluenceCurve")
An object of class “InfluenceCurve” 
### name:	  

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	NULL
[[1]]
length of Map:	 1 
Range:	Euclidean Space with dimension 1 

### Infos:
<0 x 0 matrix>
> 
> 
> 
> cleanEx()
> nameEx("InfluenceCurve")
> ### * InfluenceCurve
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfluenceCurve
> ### Title: Generating function for InfluenceCurve-class
> ### Aliases: InfluenceCurve
> ### Keywords: robust
> 
> ### ** Examples
> 
> InfluenceCurve()
An object of class “InfluenceCurve” 
### name:	 influence curve 

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Euclidean Space with dimension 1 

### Infos:
     method message
> 
> ## The function is currently defined as
> InfluenceCurve <- function(name, Curve = EuclRandVarList(EuclRandVariable(Domain = Reals())), 
+                            Risks, Infos){
+     if(missing(name))
+         name <- "influence curve"
+     if(missing(Risks))
+         Risks <- list()
+     if(missing(Infos))
+         Infos <- matrix(c(character(0),character(0)), ncol=2,
+                      dimnames=list(character(0), c("method", "message")))
+     
+     return(new("InfluenceCurve", name = name, Curve = Curve, 
+                Risks = Risks, Infos = Infos))
+ }
> 
> 
> 
> cleanEx()
> nameEx("InfoPlotWrapper")
> ### * InfoPlotWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfoPlot
> ### Title: Wrapper function for information plot method
> ### Aliases: InfoPlot
> 
> ### ** Examples
> 
> # Gamma
> fam  <-  GammaFamily()
> IC <- optIC(model = fam, risk = asCov())
> Y <- distribution(fam)
> data  <-  r(Y)(500)
> InfoPlot(IC, data, withCall = FALSE)
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
Warning in log(x/1) : NaNs produced
> 
> 
> 
> cleanEx()
> nameEx("MEstimate-class")
> ### * MEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MEstimate-class
> ### Title: MEstimate-class.
> ### Aliases: MEstimate-class Mroot Mroot,MEstimate-method
> ###   show,MEstimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("MEstimate")
Evaluations of Asymptotically linear estimate:
----------------------------------------------
An object of class “Estimate” 
generated by call
  `{}`()
estimate:
numeric(0)
asymptotic bias:
NULL
value of M equation:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("PlotICWrapper")
> ### * PlotICWrapper
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PlotIC
> ### Title: Wrapper function for plot method for IC
> ### Aliases: PlotIC
> 
> ### ** Examples
> 
> # Gamma
> fam <- GammaFamily()
> rfam <- InfRobModel(fam, ContNeighborhood(0.5))
> IC <- optIC(model = fam, risk = asCov())
> Y <- distribution(fam)
> y <- r(Y)(1000)
> PlotIC(IC, y, withCall = FALSE)
NULL
NULL
> 
> 
> 
> cleanEx()
> nameEx("RobAStBaseMASK")
> ### * RobAStBaseMASK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBaseMASK
> ### Title: Masking of/by other functions in package "RobAStBase"
> ### Aliases: RobAStBaseMASK MASKING
> ### Keywords: programming distribution documentation
> 
> ### ** Examples
> 
> RobAStBaseMASK()
######################################################################
#  On masking of and by other functions in package "RobAStBase"       
######################################################################

Attention:

*** intentional masking: ***

To be able to use the same symbol for objects of S4-classes 'kStepEstimate',
respectively of classes 'ContIC','TotalVarIC','BoundedWeight',
we intentionally mask the following function[s] --- however this/these 
function[s] may still be used in exactly the same way as before 
masking:

+start()    (package "stats")
+clip()    (package "graphics")
 
 

> 
> 
> 
> cleanEx()
> nameEx("RobAStBaseOptions")
> ### * RobAStBaseOptions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobAStBaseOptions
> ### Title: Function to change the global variables of the package
> ###   'RobAStBase'
> ### Aliases: RobAStBaseOptions getRobAStBaseOption kStepUseLast
> ### Keywords: misc robust
> 
> ### ** Examples
> 
> RobAStBaseOptions()
$kStepUseLast
[1] FALSE

$withUpdateInKer
[1] FALSE

$IC.UpdateInKer
NULL

$all.verbose
[1] FALSE

$withICList
[1] FALSE

$withPICList
[1] FALSE

> RobAStBaseOptions("kStepUseLast")
$kStepUseLast
[1] FALSE

> RobAStBaseOptions("kStepUseLast" = TRUE)
> # or
> RobAStBaseOptions(kStepUseLast = 1e-6)
> getRobAStBaseOption("kStepUseLast")
[1] 1e-06
> 
> 
> 
> cleanEx()
> nameEx("RobWeight-class")
> ### * RobWeight-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RobWeight-class
> ### Title: Robust Weight classes
> ### Aliases: RobWeight-class name,RobWeight-method name<-,RobWeight-method
> ###   weight weight,RobWeight-method weight<- weight<--methods
> ###   weight<-,RobWeight-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## prototype
> new("RobWeight")
An object of class "RobWeight"
Slot "name":
[1] "some weight"

Slot "weight":
function (x) 
1
<bytecode: 0x5113e68>
<environment: namespace:RobAStBase>

> 
> 
> 
> cleanEx()
> nameEx("TotalVarIC-class")
> ### * TotalVarIC-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarIC-class
> ### Title: Influence curve of total variation type
> ### Aliases: TotalVarIC-class CallL2Fam<-,TotalVarIC-method clipLo
> ###   clip,TotalVarIC-method clipLo,TotalVarIC-method clipLo<-
> ###   clipLo<-,TotalVarIC-method clipUp clipUp,TotalVarIC-method clipUp<-
> ###   clipUp<-,TotalVarIC-method lowerCase<-,TotalVarIC-method
> ###   neighbor,TotalVarIC-method show,TotalVarIC-method
> ###   stand<-,TotalVarIC-method
> ###   generateIC,TotalVarNeighborhood,L2ParamFamily-method
> ### Keywords: classes robust
> 
> ### ** Examples
> 
> IC1 <- new("TotalVarIC")
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("TotalVarIC")
> ### * TotalVarIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarIC
> ### Title: Generating function for TotalVarIC-class
> ### Aliases: TotalVarIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- TotalVarIC()
> plot(IC1)
NULL
> 
> 
> 
> cleanEx()
> nameEx("TotalVarNeighborhood-class")
> ### * TotalVarNeighborhood-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarNeighborhood-class
> ### Title: Total variation neighborhood
> ### Aliases: TotalVarNeighborhood-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> new("TotalVarNeighborhood")
An object of class “TotalVarNeighborhood” 
type:	 (uncond.) total variation neighborhood 
radius:	 0 
> 
> 
> 
> cleanEx()
> nameEx("TotalVarNeighborhood")
> ### * TotalVarNeighborhood
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: TotalVarNeighborhood
> ### Title: Generating function for TotalVarNeighborhood-class
> ### Aliases: TotalVarNeighborhood
> ### Keywords: models
> 
> ### ** Examples
> 
> TotalVarNeighborhood()
An object of class “TotalVarNeighborhood” 
type:	 (uncond.) total variation neighborhood 
radius:	 0 
> 
> ## The function is currently defined as
> function(radius = 0){ 
+     new("TotalVarNeighborhood", radius = radius) 
+ }
function (radius = 0) 
{
    new("TotalVarNeighborhood", radius = radius)
}
> 
> 
> 
> cleanEx()
> nameEx("biastype-methods")
> ### * biastype-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: biastype-methods
> ### Title: Methods for Function biastype in Package 'RobAStBase'
> ### Aliases: biastype,interpolRisk-method biastype
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> biastype(myrisk)
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> 
> 
> 
> cleanEx()
> nameEx("checkIC")
> ### * checkIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkIC
> ### Title: Generic Function for Checking ICs
> ### Aliases: checkIC
> ### Keywords: robust
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> checkIC(IC1)
precision of centering:	 0 
precision of Fisher consistency:
              [,1]
[1,] -5.794001e-06
precision of Fisher consistency - relativ error [%]:
              [,1]
[1,] -0.0005794001
maximum deviation 
     5.794001e-06 
> 
> 
> 
> cleanEx()
> nameEx("comparePlot")
> ### * comparePlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: comparePlot-methods
> ### Title: Compare - Plots
> ### Aliases: comparePlot comparePlot-methods comparePlot,IC,IC-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> if(require(ROptEst)){
+ 
+ N0 <- NormLocationScaleFamily(mean=0, sd=1) 
+ N0.Rob1 <- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))
+ 
+ IC1 <- optIC(model = N0, risk = asCov())
+ IC2 <- optIC(model = N0.Rob1, risk = asMSE())
+ 
+ comparePlot(IC1,IC2)
+ 
+ set.seed(12); data <- r(N0)(20)
+ comparePlot(IC1, IC2, data=data, with.lab = TRUE,
+             which.lbs = c(1:4,15:20),
+             which.Order = 1:6,
+             return.Order = TRUE)
+ 
+ ## don't run to reduce check time on CRAN
+ ## Not run: 
+ ##D ## selection of subpanels for plotting
+ ##D par(mfrow=c(1,1))
+ ##D comparePlot(IC1, IC2 ,mfColRow = FALSE, to.draw.arg=c("mean"),
+ ##D             panel.first= grid(),ylim=c(-4,4),xlim=c(-6,6))
+ ##D ## matrix-valued ylim
+ ##D comparePlot(IC1, IC2, panel.first= grid(),ylim=c(-4,4,0,4),xlim=c(-6,6))
+ ##D 
+ ##D x <- c(data,-12,10)
+ ##D comparePlot(IC1, IC2, data=x, which.Order=10,
+ ##D             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ ##D 
+ ##D Y <- Chisq(df=1)* DiscreteDistribution(c(-1,1))
+ ##D comparePlot(IC1, IC2, data=x, which.Order=10,
+ ##D             scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
+ ##D             scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q(Y),
+ ##D             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ ##D comparePlot(IC1, IC2, data=x, which.Order=10,
+ ##D             scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
+ ##D             scaleY = TRUE, scaleY.fct=p(Y), scaleY.inv=q(Y),
+ ##D             x.ticks = c(-Inf, -10, -1,0,1,10,Inf),
+ ##D             y.ticks = c(-Inf, -5, -1,0,1,5,Inf),
+ ##D             panel.first= grid(), ylim=c(-4,4,0,4), xlim=c(-6,6))
+ ##D 
+ ##D ## with use of trafo-matrix:
+ ##D G <- GammaFamily(scale = 1, shape = 2)
+ ##D ## explicitely transforming to
+ ##D ## MASS parametrization:
+ ##D mtrafo <- function(x){
+ ##D      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+ ##D      nms <- c("shape","rate")
+ ##D      fval0 <- c(x[2], 1/x[1])
+ ##D      names(fval0) <- nms
+ ##D      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+ ##D                      dimnames = list(nms,nms0))                          
+ ##D      list(fval = fval0, mat = mat0)}
+ ##D G2 <- G
+ ##D trafo(G2) <- mtrafo
+ ##D G2
+ ##D G2.Rob1 <- InfRobModel(center = G2, neighbor = ContNeighborhood(radius = 0.5))
+ ##D system.time(IC1 <- optIC(model = G2, risk = asCov()))
+ ##D system.time(IC2 <- optIC(model = G2.Rob1, risk = asMSE()))
+ ##D system.time(IC2.i <- optIC(model = G2.Rob1, risk = asMSE(normtype=InfoNorm())))
+ ##D system.time(IC2.s <- optIC(model = G2.Rob1, risk = asMSE(normtype=SelfNorm())))
+ ##D 
+ ##D comparePlot(IC1,IC2, IC2.i, IC2.s)
+ ## End(Not run)
+ 
+ }
Loading required package: ROptEst
> 
> 
> 
> cleanEx()

detaching ‘package:ROptEst’

> nameEx("cutoff-class")
> ### * cutoff-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutoff-class
> ### Title: Cutoff class for distance-distance plots
> ### Aliases: cutoff-class cutoff.quantile<-,cutoff-method cutoff.quantile<-
> ###   cutoff.quantile,cutoff-method cutoff.quantile name,cutoff-method
> ###   fct,cutoff-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> cutoff()
An object of class "cutoff"
Slot "name":
[1] "empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    quantile(slot(norm, "fct")(data), cutoff.quantile)
}
<environment: 0x8572340>

Slot "cutoff.quantile":
[1] 0.95

> 
> 
> 
> cleanEx()
> nameEx("cutoff")
> ### * cutoff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cutoff
> ### Title: Generating function(s) for class 'cutoff'
> ### Aliases: cutoff cutoff.sememp cutoff.chisq cutoff.quant
> ### Keywords: hplot
> 
> ### ** Examples
> 
> cutoff()
An object of class "cutoff"
Slot "name":
[1] "empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    quantile(slot(norm, "fct")(data), cutoff.quantile)
}
<environment: 0x81845b0>

Slot "cutoff.quantile":
[1] 0.95

> cutoff.sememp()
An object of class "cutoff"
Slot "name":
[1] "semi-empirical"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    {
        n.05 <- chol(QF)
        N0 <- matrix(rnorm(nsim * nrow(QF)), ncol = ncol(QF))
        N0 <- N0 %*% n.05
        quantile((rowSums(N0^2))^0.5, 0.95)
    }
}
<environment: 0x810b328>

Slot "cutoff.quantile":
[1] 0.95

> cutoff.chisq()
An object of class "cutoff"
Slot "name":
[1] "chisq"

Slot "fct":
function (data) 
{
    {
        QF <- if (is(norm, "QFNorm")) 
            QuadForm(norm)
        else diag(nrow(data))
    }
    {
        dim = nrow(as.matrix(data))
        qchisq(df = dim, 0.95)^0.5
    }
}
<environment: 0x7f5ae10>

Slot "cutoff.quantile":
[1] 0.95

> 
> 
> 
> cleanEx()
> nameEx("ddPlot-methods")
> ### * ddPlot-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ddPlot-methods
> ### Title: Methods for Function ddPlot in Package 'RobAStBase'
> ### Aliases: ddPlot ddPlot-methods ddPlot,matrix-method
> ###   ddPlot,numeric-method ddPlot,data.frame-method
> ### Keywords: methods hplot
> 
> ### ** Examples
> 
> MX <- matrix(rnorm(1500),nrow=6)
> QM <- matrix(rnorm(36),nrow=6); QM <- QM %*% t(QM)
> ddPlot(data=MX, dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)))
> 
> 
> 
> cleanEx()
> nameEx("getRiskFctBV-methods")
> ### * getRiskFctBV-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getRiskFctBV-methods
> ### Title: Methods for Function getRiskFctBV in Package 'RobAStBase'
> ### Aliases: getRiskFctBV getRiskFctBV-methods
> ###   getRiskFctBV,interpolRisk,ANY-method getRiskFctBV,asGRisk,ANY-method
> ###   getRiskFctBV,asMSE,ANY-method
> ###   getRiskFctBV,asSemivar,onesidedBias-method
> ###   getRiskFctBV,asSemivar,asymmetricBias-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- asMSE()
> getRiskFctBV(myrisk)
function (bias, var) 
return(bias^2 + var)
<environment: 0xd32dba0>
> 
> 
> 
> cleanEx()
> nameEx("infoPlot")
> ### * infoPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: infoPlot
> ### Title: Plot absolute and relative information
> ### Aliases: infoPlot infoPlot-methods infoPlot,IC-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> N <- NormLocationScaleFamily(mean=0, sd=1) 
> IC1 <- optIC(model = N, risk = asCov())
> infoPlot(IC1)
> 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D ## selection of subpanels for plotting
> ##D par(mfrow=c(1,2))
> ##D infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"))
> ##D infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"), log="y")
> ##D 
> ##D infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
> ##D               panel.first= grid(), ylim = c(0,4), xlim = c(-6,6))
> ##D infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
> ##D               panel.first= grid(), ylim = c(0,4,-3,3), xlim = c(-6,6))
> ##D 
> ##D par(mfrow=c(1,3))
> ##D infoPlot(IC1, mfColRow = FALSE, panel.first= grid(),
> ##D          ylim = c(0,4,0,.3,0,.8), xlim=c(-6,6))
> ##D par(mfrow=c(1,1))
> ##D 
> ##D data <- r(N)(20)
> ##D par(mfrow=c(1,3))
> ##D infoPlot(IC1, data=data, mfColRow = FALSE, panel.first= grid(),
> ##D          with.lab = TRUE, cex.pts=2,
> ##D          which.lbs = c(1:4,15:20), which.Order = 1:6,
> ##D          return.Order = TRUE)
> ##D infoPlot(IC1, data=data[1:10], mfColRow = FALSE, panel.first= grid(),
> ##D          with.lab = TRUE, cex.pts=0.7)
> ##D par(mfrow=c(1,1))
> ##D 
> ##D ICr <- makeIC(list(function(x)sign(x),function(x)sign(abs(x)-qnorm(.75))),N)
> ##D data <- r(N)(600)
> ##D data.c <- c(data, 1000*data[1:30])
> ##D par(mfrow=c(3,1))
> ##D infoPlot(ICr, data=data.c, tmar=c(4.1,0,0), bmar=c(0,0,4.1),
> ##D          xaxt=c("n","n","s"), mfColRow = FALSE, panel.first= grid(),
> ##D          cex.pts=c(.9,.9), alpha.trsp=20, lwd=2, lwdI=1.5, col=3,
> ##D          col.pts=c(3,2), colI=2, pch.pts=c(20,20), inner=FALSE,
> ##D          scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
> ##D          scaleY=TRUE, scaleY.fct=function(x) pchisq(x,df=1),
> ##D          scaleY.inv=function(x)qchisq(x,df=1),legend.cex = 1.0)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("internals_ddPlot")
> ### * internals_ddPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: internals_for_RobAStBase_ddPlot
> ### Title: Internal / Helper functions of package RobAStBase for ddPlot
> ### Aliases: internals_for_RobAStBase_ddPlot .ddPlot.MatNtNtCoCo
> ### Keywords: internal hplot
> 
> ### ** Examples
> 
> MX <- matrix(rnorm(1500),nrow=6)
> QM <- matrix(rnorm(36),nrow=6); QM <- QM %*% t(QM)
> RobAStBase:::.ddPlot.MatNtNtCoCo(data=MX, 
+         dist.y=QFNorm(QuadF=PosSemDefSymmMatrix(QM)),
+         xlab="Norm.x",ylab="Norm.y", cex.idn = 1.3, offset=0,
+         lwd=2, lwd.cutoff=4, lty=2, col.cutoff =2, col.idn="green",
+         col = "blue", adj=0.4, pos=4,id.n = sample(1:200,size=100),
+         lab.pts=letters,log="x", main="GA", sub="NO",cex.sub=0.2)
Warning in (function (which = "plot", lty = "solid", ...)  :
  "log" is not a graphical parameter
> 
> 
> 
> cleanEx()
> nameEx("interpolRisk-class")
> ### * interpolRisk-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interpolRisk-class
> ### Title: Interpolated Risks
> ### Aliases: interpolRisk-class OMSRRisk-class RMXRRisk-class MBRRisk-class
> ###   OMSRRisk RMXRRisk MBRRisk
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("OMSRRisk")
An object of class “OMSRRisk” 
risk type:	 .OMSE 
> OMSRRisk()
An object of class “OMSRRisk” 
risk type:	 .OMSE 
> RMXRRisk()
An object of class “RMXRRisk” 
risk type:	 .RMXE 
> MBRRisk()
An object of class “MBRRisk” 
risk type:	 .MBRE 
> myrisk <- MBRRisk(samplesize=100)
> samplesize(myrisk)
[1] 100
> samplesize(myrisk) <- 20
> 
> 
> 
> cleanEx()
> nameEx("kStepEstimator")
> ### * kStepEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kStepEstimator
> ### Title: Function for the computation of k-step estimates
> ### Aliases: kStepEstimator
> ### Keywords: univar robust
> 
> ### ** Examples
> 
> if(require(ROptEst)){
+ ## 1. generate a contaminated sample
+ ind <- rbinom(100, size=1, prob=0.05)
+ x <- rnorm(100, mean=0, sd=(1-ind) + ind*9)
+ 
+ ## 2. Kolmogorov(-Smirnov) minimum distance estimator
+ (est0 <- MDEstimator(x=x, NormLocationScaleFamily()))
+ 
+ ## 3. k-step estimation: radius known
+ N1 <- NormLocationScaleFamily(mean=estimate(est0)["mean"], sd=estimate(est0)["sd"])
+ N1.Rob <- InfRobModel(center = N1, neighbor = ContNeighborhood(radius = 0.5))
+ IC1 <- optIC(model = N1.Rob, risk = asMSE())
+ (est1 <- kStepEstimator(x, IC1, est0, steps = 3, withPIC = TRUE))
+ estimate(est1)
+ ksteps(est1)
+ pICList(est1)
+ start(est1)
+ 
+ ## don't run to reduce check time on CRAN
+ ## Not run: 
+ ##D ## a transformed model
+ ##D tfct <- function(x){
+ ##D     nms0 <- c("mean","sd")
+ ##D     nms  <- "comb"
+ ##D     fval0 <- x[1]+2*x[2]
+ ##D     names(fval0) <- nms
+ ##D     mat0 <- matrix(c(1,2), nrow = 1, dimnames = list(nms,nms0))
+ ##D     return(list(fval = fval0, mat = mat0))
+ ##D }
+ ##D 
+ ##D N1.traf <- N1; trafo(N1.traf) <- tfct
+ ##D N1R.traf <- N1.Rob; trafo(N1R.traf) <- tfct
+ ##D IC1.traf <- optIC(model = N1R.traf, risk = asMSE())
+ ##D (est0.traf <- MDEstimator(x, N1.traf))
+ ##D (est1.traf <- kStepEstimator(x, IC1.traf, est0, steps = 3,
+ ##D                 withIC = TRUE, withPIC = TRUE, withUpdateInKer = FALSE))
+ ##D (est1a.traf <- kStepEstimator(x, IC1.traf, est0, steps = 3,
+ ##D                 withIC = TRUE, withPIC = TRUE, withUpdateInKer = TRUE))
+ ##D estimate(est1.traf)
+ ##D ksteps(est1.traf)
+ ##D pICList(est1.traf)
+ ##D startval(est1.traf)
+ ##D 
+ ##D untransformed.estimate(est1.traf)
+ ##D uksteps(est1.traf)
+ ##D ICList(est1.traf)
+ ##D ustartval(est1.traf)
+ ##D 
+ ##D estimate(est1a.traf)
+ ##D ksteps(est1a.traf)
+ ##D pICList(est1a.traf)
+ ##D startval(est1a.traf)
+ ##D 
+ ##D untransformed.estimate(est1a.traf)
+ ##D uksteps(est1a.traf)
+ ##D ICList(est1a.traf)
+ ##D ustartval(est1a.traf)
+ ## End(Not run)
+ }
Loading required package: ROptEst
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = NormLocationScaleFamily())
samplesize:   100
estimate:
      mean         sd 
-0.1176227  0.7942553 
Criterion:
Kolmogorov distance 
              1e+20 
> 
> 
> 
> cleanEx()

detaching ‘package:ROptEst’

> nameEx("makeIC-methods")
> ### * makeIC-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeIC-methods
> ### Title: Generic Function for making ICs consistent at a possibly
> ###   different model
> ### Aliases: makeIC makeIC-methods makeIC,IC,missing-method
> ###   makeIC,IC,L2ParamFamily-method makeIC,list,L2ParamFamily-method
> ###   makeIC,function,L2ParamFamily-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> ## default IC
> IC1 <- new("IC")
> 
> ## L2-differentiable parametric family
> B <- BinomFamily(13, 0.3)
> 
> ## check IC properties
> checkIC(IC1, B)
precision of centering:	 3.9 
precision of Fisher consistency:
     prob
prob   12
precision of Fisher consistency - relativ error [%]:
     prob
prob 1200
maximum deviation 
               12 
> 
> ## make IC
> IC2 <- makeIC(IC1, B)
> 
> ## check IC properties
> checkIC(IC2)
precision of centering:	 7.272702e-17 
precision of Fisher consistency:
              prob
prob -1.110223e-16
precision of Fisher consistency - relativ error [%]:
              prob
prob -1.110223e-14
maximum deviation 
     1.110223e-16 
> 
> ## slot modifyIC is filled in case of IC2
> IC3 <- modifyIC(IC2)(BinomFamily(13, 0.2), IC2)
> checkIC(IC3)
precision of centering:	 -3.091672e-18 
precision of Fisher consistency:
     prob
prob    0
precision of Fisher consistency - relativ error [%]:
     prob
prob    0
maximum deviation 
     3.091672e-18 
> ## identical to
> checkIC(IC3, BinomFamily(13, 0.2))
precision of centering:	 -3.091672e-18 
precision of Fisher consistency:
     prob
prob    0
precision of Fisher consistency - relativ error [%]:
     prob
prob    0
maximum deviation 
     3.091672e-18 
> 
> IC4 <- makeIC(sin, B)
$Curve
An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

$CallL2Fam
L2Fam@fam.call

An object of class “IC” 
### name:	 square integrable (partial) influence curve 
### L2-differentiable parametric family:	 Binomial family 

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

### Infos:
     method message
> checkIC(IC4)
precision of centering:	 2.715274e-17 
precision of Fisher consistency:
              prob
prob -1.110223e-16
precision of Fisher consistency - relativ error [%]:
              prob
prob -1.110223e-14
maximum deviation 
     1.110223e-16 
> 
> (IC5 <- makeIC(list(function(x)x^3), B, name="a try"))
An object of class “IC” 
### name:	 a try 
### L2-differentiable parametric family:	 Binomial family 

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

### Infos:
     method message                                                  
[1,] "IC<-" "generated by affine linear trafo to enforce consistency"
> plot(IC5)
NULL
> checkIC(IC5)
precision of centering:	 2.565774e-17 
precision of Fisher consistency:
     prob
prob    0
precision of Fisher consistency - relativ error [%]:
     prob
prob    0
maximum deviation 
     2.565774e-17 
> 
> ## don't run to reduce check time on CRAN
> ## Not run: 
> ##D N0 <- NormLocationScaleFamily()
> ##D IC6 <- makeIC(list(sin,cos),N0)
> ##D plot(IC6)
> ##D checkIC(IC6)
> ##D 
> ##D getRiskIC(IC6,risk=trAsCov())$trAsCov$value
> ##D getRiskIC(IC6,risk=asBias(),neighbor=ContNeighborhood())$asBias$value
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("normtype-methods")
> ### * normtype-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normtype-methods
> ### Title: Methods for Function normtype in Package 'RobAStBase'
> ### Aliases: normtype,interpolRisk-method normtype
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> normtype(myrisk)
An object of class "NormType"
Slot "name":
[1] "EuclideanNorm"

Slot "fct":
function(x){ 
    if(is.vector(x)) 
        return(abs(x))
    else 
        return(sqrt(colSums(x^2)))
}
<bytecode: 0xc3daf30>
<environment: namespace:distrMod>

> 
> 
> 
> cleanEx()
> nameEx("optIC")
> ### * optIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optIC
> ### Title: Generic function for the computation of optimally robust ICs
> ### Aliases: optIC optIC-methods optIC,L2ParamFamily,asCov-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> B <- BinomFamily(size = 25, prob = 0.25) 
> 
> ## classical optimal IC
> IC0 <- optIC(model = B, risk = asCov())
> plot(IC0) # plot IC
NULL
> checkIC(IC0, B)
precision of centering:	 -7.3919e-18 
precision of Fisher consistency:
             prob
prob 2.220446e-16
precision of Fisher consistency - relativ error [%]:
             prob
prob 2.220446e-14
maximum deviation 
     2.220446e-16 
> 
> 
> 
> cleanEx()
> nameEx("outlyingPlotIC")
> ### * outlyingPlotIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: outlyingPlotIC
> ### Title: Function outlyingPlotIC in Package 'RobAStBase'
> ### Aliases: outlyingPlotIC
> ### Keywords: hplot
> 
> ### ** Examples
> 
> if(require(ROptEst)){
+ ## generates normal location and scale family with mean = -2 and sd = 3
+ N0 <- NormLocationScaleFamily()
+ N0.IC0 <- optIC(model = N0, risk = asCov())
+ N0.Rob1 <- InfRobModel(center = N0, neighbor = ContNeighborhood(radius = 0.5))
+ N0.IC1 <- optIC(model = N0.Rob1, risk = asMSE())
+ xn <- c(rnorm(100),rcauchy(20)+20)
+ outlyingPlotIC(xn, IC.x=N0.IC0)
+ outlyingPlotIC(xn, IC.x=N0.IC1)
+ }
Loading required package: ROptEst
Fall 1

An object of class "PosSemDefSymmMatrix"
           X1         X2
X1 0.63213606 0.05017187
X2 0.05017187 0.03395346
Warning in stats::runif(length(x), -amount, amount) : NAs produced
Warning in stats::runif(length(x), -amount, amount) : NAs produced
Fall 1

An object of class "PosSemDefSymmMatrix"
          X1        X2
X1 1.5888364 0.1964485
X2 0.1964485 0.2071058
> 
> 
> 
> cleanEx()

detaching ‘package:ROptEst’

> nameEx("plot-methods")
> ### * plot-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot-methods
> ### Title: Methods for Function plot in Package 'RobAStBase'
> ### Aliases: plot plot-methods plot,IC,missing-method
> ###   plot,IC,numeric-method
> ### Keywords: methods distribution
> 
> ### ** Examples
> 
> IC1 <- new("IC")
> plot(IC1)
NULL
> plot(IC1, main = TRUE, panel.first= grid(),
+      col = "blue", cex.main = 2, cex.inner = 1)
NULL
> 
> ### selection of subpanels for plotting
> N <- NormLocationScaleFamily(mean=0, sd=1) 
> IC2 <- optIC(model = N, risk = asCov())
> par(mfrow=c(1,1))
> plot(IC2, main = TRUE, panel.first= grid(),
+      col = "blue", cex.main = 2, cex.inner = 0.6,
+      mfColRow = FALSE, to.draw.arg=c("sd"))
NULL
> 
> ## xlim and ylim arguments
> plot(IC2, main = TRUE, panel.first= grid(), 
+      ylim=c(-3,3), xlim=c(-2,3))
[1] -2  3
[1] -2  3
> plot(IC2, main = TRUE, panel.first= grid(), 
+      ylim=c(-3,3,-1,3), xlim=c(-2,3),
+      with.legend = TRUE)
[1] -2  3
[1] -2  3
> 
> data <- r(N)(30)
> plot(IC2, data, panel.first= grid(),
+      ylim = c(-3,3,-1,3), xlim=c(-2,3),
+      cex.pts = 3, pch.pts = 1:2, col.pts="green",
+      with.lab = TRUE, which.lbs = c(1:4,15:20),
+      which.Order = 1:6, return.Order = TRUE)
[1] -2  3
[1] -2  3
 [1]  4 15 18  3 19  1 20  2 16 17
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("qqplot")
> ### * qqplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qqplot
> ### Title: Methods for Function qqplot in Package 'RobAStBase'
> ### Aliases: qqplot qqplot-methods qqplot,ANY,RobModel-method
> ###   qqplot,ANY,InfRobModel-method qqplot,ANY,kStepEstimate-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> qqplot(rnorm(40, mean = 15, sd = sqrt(30)), Chisq(df=15))
> RobM <- InfRobModel(center = NormLocationFamily(mean=13,sd=sqrt(28)),
+                     neighbor = ContNeighborhood(radius = 0.4))
> x <- rnorm(20, mean = 15, sd = sqrt(30))
> qqplot(x, RobM)
> ## to reduce check time
> ## further examples for ANY,kStepEstimator-method
> ## in example to roptest() in package ROptEst
> 
> 
> 
> cleanEx()
> nameEx("samplesize-methods")
> ### * samplesize-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: samplesize-methods
> ### Title: Methods for Function samplesize in Package 'RobAStBase'
> ### Aliases: samplesize,interpolRisk-method samplesize
> ###   samplesize<-,interpolRisk-method samplesize<-
> ### Keywords: classes
> 
> ### ** Examples
> 
> myrisk <- MBRRisk(samplesize=100)
> samplesize(myrisk)
[1] 100
> samplesize(myrisk) <- 20
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  15.547 0.096 15.634 0.001 0.002 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
