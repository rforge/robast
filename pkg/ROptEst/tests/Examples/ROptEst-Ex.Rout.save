
R version 2.12.1 Patched (2011-01-04 r53913)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ROptEst"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ROptEst')
Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for start-up messages (version 0.7.1)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
Loading required package: SweaveListingUtils
:SweaveListingUtils>  Utilities for Sweave together with
:SweaveListingUtils>  TeX listings package (version 0.5)
:SweaveListingUtils> 
:SweaveListingUtils>  Some functions from package 'base'
:SweaveListingUtils>  are intentionally masked ---see
:SweaveListingUtils>  SweaveListingMASK().
:SweaveListingUtils> 
:SweaveListingUtils>  Note that global options are
:SweaveListingUtils>  controlled by
:SweaveListingUtils>  SweaveListingoptions() ---c.f.
:SweaveListingUtils>  ?"SweaveListingoptions".
:SweaveListingUtils> 
:SweaveListingUtils>  For more information see
:SweaveListingUtils>  ?"SweaveListingUtils",
:SweaveListingUtils>  NEWS("SweaveListingUtils")
:SweaveListingUtils>  There is a vignette to this
:SweaveListingUtils>  package; try
:SweaveListingUtils>  vignette("ExampleSweaveListingUtils").


Attaching package: 'SweaveListingUtils'

The following object(s) are masked from 'package:base':

    library, require

:distr>  Object oriented implementation of distributions (version
:distr>  2.3)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: 'distr'

The following object(s) are masked from 'package:stats':

    df, qqplot, sd

Loading required package: distrEx
Loading required package: evd
Loading required package: actuar

Attaching package: 'actuar'

The following object(s) are masked from 'package:grDevices':

    cm

:distrEx>  Extensions of package distr (version 2.3)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See distrExMASK().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: 'distrEx'

The following object(s) are masked from 'package:stats':

    IQR, mad, median, var

Loading required package: distrMod
Loading required package: RandVar
:RandVar>  Implementation of random variables (version 0.8)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object oriented implementation of probability models
:distrMod>  (version 2.3)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: 'distrMod'

The following object(s) are masked from 'package:stats4':

    confint

The following object(s) are masked from 'package:stats':

    confint

The following object(s) are masked from 'package:base':

    norm

Loading required package: RobAStBase
:RobAStBase>  Robust Asymptotic Statistics (version 0.8)
:RobAStBase> 
:RobAStBase>  Some functions from pkg's 'stats' and 'graphics'
:RobAStBase>  are intentionally masked ---see RobAStBaseMASK().
:RobAStBase> 
:RobAStBase>  Note that global options are controlled by
:RobAStBase>  RobAStBaseoptions() ---c.f. ?"RobAStBaseoptions".
:RobAStBase> 
:RobAStBase>  For more information see ?"RobAStBase",
:RobAStBase>  NEWS("RobAStBase"), as well as
:RobAStBase>    http://robast.r-forge.r-project.org/


Attaching package: 'RobAStBase'

The following object(s) are masked from 'package:stats':

    start

The following object(s) are masked from 'package:graphics':

    clip

> 
> assign(".oldSearch", search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("0ROptEst-package")
> ### * 0ROptEst-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ROptEst-package
> ### Title: Optimally robust estimation
> ### Aliases: ROptEst-package ROptEst
> ### Keywords: package
> 
> ### ** Examples
> 
> library(ROptEst)
> 
> ## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
> x <- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
+        rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
+        rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))
> 
> ## ML-estimate from package distrMod
> MLest <- MLEstimator(x, PoisFamily())
> MLest
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = PoisFamily())
samplesize:   2608
estimate:
             
  3.87154908 
 (0.03852908)
asymptotic (co)variance (multiplied with samplesize):
[1] 3.871549
Criterion:
negative log-likelihood 
               5352.105 
> ## confidence interval based on CLT
> confint(MLest)
A[n] asymptotic (CLT-based) confidence interval:
        2.5 %   97.5 %
[1,] 3.796033 3.947065
Type of estimator: Maximum likelihood estimate
samplesize:   2608
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = PoisFamily())
> 
> ## compute optimally (w.r.t to MSE) robust estimator (unknown contamination)
> robest <- roptest(x, PoisFamily(), eps.upper = 0.1, steps = 3)
> estimate(robest)
  lambda 
3.908135 
> ## check influence curve
> checkIC(pIC(robest))
precision of centering:	 -2.707017e-08 
precision of Fisher consistency:
              lambda
lambda -1.980378e-06
maximum deviation 
     1.980378e-06 
> ## plot influence curve
> plot(pIC(robest))
> ## confidence interval based on LAN - neglecting bias
> confint(robest)
A[n] asymptotic (LAN-based) confidence interval:
          2.5 %   97.5 %
lambda 3.826169 3.990102
Type of estimator: 3-step estimate
samplesize:   2608
Call by which estimate was produced:
roptest(x = x, L2Fam = PoisFamily(), eps.upper = 0.1, steps = 3)
> ## confidence interval based on LAN - including bias
> confint(robest, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
          2.5 %   97.5 %
lambda 3.761616 4.054655
Type of estimator: 3-step estimate
samplesize:   2608
Call by which estimate was produced:
roptest(x = x, L2Fam = PoisFamily(), eps.upper = 0.1, steps = 3)
> 
> 
> 
> cleanEx()
> nameEx("asAnscombe-class")
> ### * asAnscombe-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asAnscombe-class
> ### Title: Asymptotic Anscombe risk
> ### Aliases: asAnscombe-class eff eff,asAnscombe-method
> ###   show,asAnscombe-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asAnscombe")
An object of class “asAnscombe” 
risk type:	 optimal bias robust IC for given ARE in the ideal model 
ARE in the ideal model:	 0.95 
> 
> 
> 
> cleanEx()
> nameEx("asAnscombe")
> ### * asAnscombe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asAnscombe
> ### Title: Generating function for asAnscombe-class
> ### Aliases: asAnscombe
> ### Keywords: robust
> 
> ### ** Examples
> 
> asAnscombe()
An object of class “asAnscombe” 
risk type:	 optimal bias robust IC for given ARE in the ideal model 
ARE in the ideal model:	 0.95 
> 
> ## The function is currently defined as
> function(eff = .95, biastype = symmetricBias(), normtype = NormType()){ 
+     new("asAnscombe", eff = eff, biastype = biastype, normtype = normtype) }
function (eff = 0.95, biastype = symmetricBias(), normtype = NormType()) 
{
    new("asAnscombe", eff = eff, biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asL1-class")
> ### * asL1-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asL1-class
> ### Title: Asymptotic mean absolute error
> ### Aliases: asL1-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asMSE")
An object of class “asMSE” 
risk type:	 asymptotic mean square error 
> 
> 
> 
> cleanEx()
> nameEx("asL1")
> ### * asL1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asL1
> ### Title: Generating function for asMSE-class
> ### Aliases: asL1
> ### Keywords: robust
> 
> ### ** Examples
> 
> asL1()
An object of class “asL1” 
risk type:	 asymptotic mean absolute error 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+          new("asL1", biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asL1", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asL4-class")
> ### * asL4-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asL4-class
> ### Title: Asymptotic mean power 4 error
> ### Aliases: asL4-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asMSE")
An object of class “asMSE” 
risk type:	 asymptotic mean square error 
> 
> 
> 
> cleanEx()
> nameEx("asL4")
> ### * asL4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asL4
> ### Title: Generating function for asL4-class
> ### Aliases: asL4
> ### Keywords: robust
> 
> ### ** Examples
> 
> asL4()
An object of class “asL4” 
risk type:	 asymptotic mean power 4 error 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+          new("asL4", biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asL4", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("cniperCont")
> ### * cniperCont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cniperCont
> ### Title: Generic Functions for Computation and Plot of Cniper
> ###   Contamination and Cniper Points.
> ### Aliases: cniperCont cniperCont-methods
> ###   cniperCont,IC,IC,L2ParamFamily,ContNeighborhood,asMSE-method
> ###   cniperPoint cniperPoint-methods
> ###   cniperPoint,L2ParamFamily,ContNeighborhood,asMSE-method
> ###   cniperPointPlot cniperPointPlot-methods
> ###   cniperPointPlot,L2ParamFamily,ContNeighborhood,asMSE-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> ## cniper contamination
> P <- PoisFamily(lambda = 4)
> RobP1 <- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 0.1))
> IC1 <- optIC(model=RobP1, risk=asMSE())
> RobP2 <- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 1))
> IC2 <- optIC(model=RobP2, risk=asMSE())
> cniperCont(IC1 = IC1, IC2 = IC2, L2Fam = P, 
+            neighbor = ContNeighborhood(radius = 0.5), 
+            risk = asMSE(),
+            lower = 0, upper = 8, n = 101)
> 
> ## cniper point plot
> cniperPointPlot(P, neighbor = ContNeighborhood(radius = 0.5), 
+                 risk = asMSE(), lower = 0, upper = 10)
> 
> ## cniper point
> cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
+             risk = asMSE(), lower = 0, upper = 4)
cniper point 
   0.7803439 
> cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
+             risk = asMSE(), lower = 4, upper = 8)
cniper point 
    7.219656 
> 
> 
> 
> cleanEx()
> nameEx("getL1normL2deriv")
> ### * getL1normL2deriv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getL1normL2deriv
> ### Title: Calculation of L1 norm of L2derivative
> ### Aliases: getL1normL2deriv getL1normL2deriv-methods
> ###   getL1normL2deriv,UnivariateDistribution-method
> ###   getL1normL2deriv,RealRandVariable-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> ##
> 
> 
> 
> cleanEx()
> nameEx("getL2normL2deriv")
> ### * getL2normL2deriv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getL2normL2deriv
> ### Title: Calculation of L2 norm of L2derivative
> ### Aliases: getL2normL2deriv
> ### Keywords: robust
> 
> ### ** Examples
> 
> ##
> 
> 
> 
> cleanEx()
> nameEx("getMaxIneff")
> ### * getMaxIneff
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getMaxIneff
> ### Title: getMaxIneff - computation of the maximal inefficiency of an IC
> ### Aliases: getMaxIneff
> ### Keywords: robust
> 
> ### ** Examples
> 
> N0 <- NormLocationFamily(mean=2, sd=3)
> ## L_2 family + infinitesimal neighborhood
> neighbor <- ContNeighborhood(radius = 0.5)
> N0.Rob1 <- InfRobModel(center = N0, neighbor = neighbor)
> ## OBRE solution (ARE 95%)
> N0.ICA <- optIC(model = N0.Rob1, risk = asAnscombe(.95))
minimal bound:	 3.759947 
minimal bound:	 3.759947 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.0009839269 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.045311 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.0389404 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04095049 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096877 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096873 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096877 
> ## OMSE solution radius 0.5
> N0.ICM <- optIC(model=N0.Rob1, risk=asMSE())
> ## RMX solution 
> N0.ICR <- radiusMinimaxIC(L2Fam=N0, neighbor=neighbor,risk=asMSE())
> 
> getMaxIneff(N0.ICA,neighbor)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 1.658389
> getMaxIneff(N0.ICM,neighbor)
[1] 1.265537
> getMaxIneff(N0.ICR,neighbor)
[1] 1.180746
> 
> N0ls <- NormLocationScaleFamily()
> ICsc <- makeIC(list(sin,cos),N0ls)
> getMaxIneff(ICsc,neighbor)
Warning in A[DA.comp] <- matrix(param[1:lA.comp], ncol = k, nrow = p) :
  number of items to replace is not a multiple of replacement length
[1] 2.679436
> 
> 
> 
> 
> cleanEx()
> nameEx("getReq")
> ### * getReq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getReq
> ### Title: getReq - computation of the radius interval where IC1 is better
> ###   than IC2
> ### Aliases: getReq
> ### Keywords: robust
> 
> ### ** Examples
> 
> N0 <- NormLocationFamily(mean=2, sd=3)
> ## L_2 family + infinitesimal neighborhood
> neighbor <- ContNeighborhood(radius = 0.5)
> N0.Rob1 <- InfRobModel(center = N0, neighbor = neighbor)
> ## OBRE solution (ARE 95%)
> N0.ICA <- optIC(model = N0.Rob1, risk = asAnscombe(.95))
minimal bound:	 3.759947 
minimal bound:	 3.759947 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.0009839269 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.045311 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.0389404 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04095049 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096877 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096873 
minimal bound:	 3.759947 
maximum iterations reached!
 achieved precision:	 0.04096877 
> ## MSE solution
> N0.ICM <- optIC(model=N0.Rob1, risk=asMSE())
> ## RMX solution
> N0.ICR <- radiusMinimaxIC(L2Fam=N0, neighbor=neighbor,risk=asMSE())
> 
> getReq(asMSE(),neighbor,N0.ICA,N0.ICM,n=1)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.0000000 0.3750825
> getReq(asMSE(),neighbor,N0.ICA,N0.ICM,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.00000000 0.06848038
> getReq(asL1(),neighbor,N0.ICA,N0.ICM,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.00000000 0.06544434
> getReq(asL4(),neighbor,N0.ICA,N0.ICM,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.0000000 0.0754216
> getReq(asMSE(),neighbor,N0.ICA,N0.ICR,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.00000000 0.07544307
> getReq(asL1(),neighbor,N0.ICA,N0.ICR,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.00000000 0.07161849
> getReq(asL4(),neighbor,N0.ICA,N0.ICR,n=30)
Warning in .local(IC, risk, L2Fam, ...) :
  The maximum deviation from the exact IC properties is 0.0020208733776802
This is larger than the specified 'tol' => the result may be wrong
[1] 0.00000000 0.08429762
> getReq(asMSE(),neighbor,N0.ICM,N0.ICR,n=30)
[1] 0.0000000 0.1016517
> 
> ### when to use MAD and when Qn 
> ##  for Qn, see C. Croux, P. Rousseeuw (1993). Alternatives to the Median 
> ##      Absolute Deviation, JASA 88(424):1273-1283
> L2M <- NormScaleFamily()
> IC.mad <- makeIC(function(x)sign(abs(x)-qnorm(.75)),L2M)
$Curve
An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

$CallL2Fam
L2Fam@fam.call

An object of class “IC” 
### name:	 square integrable (partial) influence curve 
### L2-differentiable parametric family:	 normal scale family 

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

### Infos:
     method message
> d.qn <- (2^.5*qnorm(5/8))^-1
> IC.qn <- makeIC(function(x) d.qn*(1/4 - pnorm(x+1/d.qn) + pnorm(x-1/d.qn)), L2M)
$Curve
An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

$CallL2Fam
L2Fam@fam.call

An object of class “IC” 
### name:	 square integrable (partial) influence curve 
### L2-differentiable parametric family:	 normal scale family 

### 'Curve':	An object of class “EuclRandVarList” 
Domain:	Real Space with dimension 1 
[[1]]
length of Map:	 1 
Range:	Real Space with dimension 1 

### Infos:
     method message
> getReq(asMSE(), neighbor, IC.mad, IC.qn)
[1] 0.5074459       Inf
> # => MAD is better once r > 0.5144 (i.e. for more than 2 outliers for n = 30)
> 
> 
> 
> cleanEx()
> nameEx("leastFavorableRadius")
> ### * leastFavorableRadius
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: leastFavorableRadius
> ### Title: Generic Function for the Computation of Least Favorable Radii
> ### Aliases: leastFavorableRadius leastFavorableRadius-methods
> ###   leastFavorableRadius,L2ParamFamily,UncondNeighborhood,asGRisk-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> N <- NormLocationFamily(mean=0, sd=1) 
> leastFavorableRadius(L2Fam=N, neighbor=ContNeighborhood(),
+                      risk=asMSE(), rho=0.5)
current radius:	 0.3820278 	inefficiency:	 1.039514 
current radius:	 0.6180722 	inefficiency:	 1.043963 
current radius:	 0.7639556 	inefficiency:	 1.041503 
current radius:	 0.6008356 	inefficiency:	 1.044073 
current radius:	 0.5598913 	inefficiency:	 1.044123 
current radius:	 0.4919535 	inefficiency:	 1.043417 
current radius:	 0.5735221 	inefficiency:	 1.044142 
current radius:	 0.5739285 	inefficiency:	 1.044142 
current radius:	 0.5736396 	inefficiency:	 1.044142 
current radius:	 0.5735989 	inefficiency:	 1.044142 
current radius:	 0.5736803 	inefficiency:	 1.044142 
current radius:	 0.5736396 	inefficiency:	 1.044142 
$rho
[1] 0.5

$leastFavorableRadius
[1] 0.5736396

$`asMSE-inefficiency`
[1] 1.044142

> 
> 
> 
> cleanEx()
> nameEx("lowerCaseRadius")
> ### * lowerCaseRadius
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lowerCaseRadius
> ### Title: Computation of the lower case radius
> ### Aliases: lowerCaseRadius lowerCaseRadius-methods
> ###   lowerCaseRadius,L2ParamFamily,ContNeighborhood,asMSE,ANY-method
> ###   lowerCaseRadius,L2ParamFamily,TotalVarNeighborhood,asMSE,ANY-method
> ###   lowerCaseRadius,L2ParamFamily,ContNeighborhood,asMSE,onesidedBias-method
> ###   lowerCaseRadius,UnivariateDistribution,ContNeighborhood,asMSE,onesidedBias-method
> ###   lowerCaseRadius,L2ParamFamily,ContNeighborhood,asMSE,asymmetricBias-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> lowerCaseRadius(BinomFamily(size = 10), ContNeighborhood(), asMSE())
lower case radius 
         0.690335 
> lowerCaseRadius(BinomFamily(size = 10), TotalVarNeighborhood(), asMSE())
lower case radius 
        0.3451675 
> 
> 
> 
> cleanEx()
> nameEx("optIC")
> ### * optIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optIC
> ### Title: Generic function for the computation of optimally robust ICs
> ### Aliases: optIC optIC-methods optIC,InfRobModel,asRisk-method
> ###   optIC,InfRobModel,asUnOvShoot-method
> ###   optIC,FixRobModel,fiUnOvShoot-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> B <- BinomFamily(size = 25, prob = 0.25) 
> 
> ## classical optimal IC
> IC0 <- optIC(model = B, risk = asCov())
> plot(IC0) # plot IC
> checkIC(IC0, B)
precision of centering:	 -4.254490e-18 
precision of Fisher consistency:
             prob
prob 2.220446e-16
maximum deviation 
     2.220446e-16 
> 
> 
> 
> cleanEx()
> nameEx("optRisk")
> ### * optRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optRisk
> ### Title: Generic function for the computation of the minimal risk
> ### Aliases: optRisk optRisk-methods optRisk,L2ParamFamily,asCov-method
> ###   optRisk,InfRobModel,asRisk-method
> ###   optRisk,FixRobModel,fiUnOvShoot-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> optRisk(model = NormLocationScaleFamily(), risk = asCov())
$asCov
     mean  sd
mean    1 0.0
sd      0 0.5

> 
> 
> 
> cleanEx()
> nameEx("radiusMinimaxIC")
> ### * radiusMinimaxIC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: radiusMinimaxIC
> ### Title: Generic function for the computation of the radius minimax IC
> ### Aliases: radiusMinimaxIC radiusMinimaxIC-methods
> ###   radiusMinimaxIC,L2ParamFamily,UncondNeighborhood,asGRisk-method
> ### Keywords: robust
> 
> ### ** Examples
> 
> N <- NormLocationFamily(mean=0, sd=1) 
> radIC <- radiusMinimaxIC(L2Fam=N, neighbor=ContNeighborhood(), 
+                          risk=asMSE(), loRad=0.1, upRad=0.5)
> checkIC(radIC)
precision of centering:	 -8.135927e-16 
precision of Fisher consistency:
              mean
mean -3.502745e-06
maximum deviation 
     3.502745e-06 
> 
> 
> 
> cleanEx()
> nameEx("roptest")
> ### * roptest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roptest
> ### Title: Optimally robust estimation
> ### Aliases: roptest
> ### Keywords: robust
> 
> ### ** Examples
> 
> #############################
> ## 1. Binomial data
> #############################
> ## generate a sample of contaminated data
> ind <- rbinom(100, size=1, prob=0.05) 
> x <- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)
> 
> ## ML-estimate
> MLest <- MLEstimator(x, BinomFamily(size = 25))
> estimate(MLest)
[1] 0.2684
> confint(MLest)
A[n] asymptotic (CLT-based) confidence interval:
         2.5 %    97.5 %
[1,] 0.2510297 0.2857703
Type of estimator: Maximum likelihood estimate
samplesize:   100
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = BinomFamily(size = 25))
Fixed part of the parameter at which estimate was produced:
size 
  25 
> 
> ## compute optimally robust estimator (known contamination)
> robest1 <- roptest(x, BinomFamily(size = 25), eps = 0.05, steps = 3)
> estimate(robest1)
     prob 
0.2564327 
> confint(robest1, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
        2.5 %    97.5 %
prob 0.237641 0.2752245
Type of estimator: 3-step estimate
samplesize:   100
Call by which estimate was produced:
roptest(x = x, L2Fam = BinomFamily(size = 25), eps = 0.05, steps = 3)
Fixed part of the parameter at which estimate was produced:
size 
  25 
> ## neglecting bias
> confint(robest1)
A[n] asymptotic (LAN-based) confidence interval:
         2.5 %    97.5 %
prob 0.2382143 0.2746511
Type of estimator: 3-step estimate
samplesize:   100
Call by which estimate was produced:
roptest(x = x, L2Fam = BinomFamily(size = 25), eps = 0.05, steps = 3)
Fixed part of the parameter at which estimate was produced:
size 
  25 
> plot(pIC(robest1))
> qq1 <- qqplot(x, robest1, cex.pch=1.5, exp.cex2.pch = -.25,
+               exp.fadcol.pch = .55, jit.fac=.9)
> str(qq1)
List of 2
 $ x: num [1:100] 2 2.86 2.95 3.07 3.13 ...
 $ y: num [1:100] 0.856 1.838 1.863 2.854 2.986 ...
> 
> ## compute optimally robust estimator (unknown contamination)
> robest2 <- roptest(x, BinomFamily(size = 25), eps.lower = 0, eps.upper = 0.2, steps = 3)
> estimate(robest2)
     prob 
0.2564060 
> confint(robest2, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %    97.5 %
prob 0.2375772 0.2752347
Type of estimator: 3-step estimate
samplesize:   100
Call by which estimate was produced:
roptest(x = x, L2Fam = BinomFamily(size = 25), eps.lower = 0, 
    eps.upper = 0.2, steps = 3)
Fixed part of the parameter at which estimate was produced:
size 
  25 
> plot(pIC(robest2))
> 
> ## total variation neighborhoods (known deviation)
> robest3 <- roptest(x, BinomFamily(size = 25), eps = 0.025, 
+                    neighbor = TotalVarNeighborhood(), steps = 3)
> estimate(robest3)
     prob 
0.2563265 
> confint(robest3, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %    97.5 %
prob 0.2375738 0.2750792
Type of estimator: 3-step estimate
samplesize:   100
Call by which estimate was produced:
roptest(x = x, L2Fam = BinomFamily(size = 25), eps = 0.025, neighbor = TotalVarNeighborhood(), 
    steps = 3)
Fixed part of the parameter at which estimate was produced:
size 
  25 
> plot(pIC(robest3))
> 
> ## total variation neighborhoods (unknown deviation)
> robest4 <- roptest(x, BinomFamily(size = 25), eps.lower = 0, eps.upper = 0.1, 
+                    neighbor = TotalVarNeighborhood(), steps = 3)
> estimate(robest4)
     prob 
0.2563281 
> confint(robest4, method = symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %    97.5 %
prob 0.2375777 0.2750785
Type of estimator: 3-step estimate
samplesize:   100
Call by which estimate was produced:
roptest(x = x, L2Fam = BinomFamily(size = 25), eps.lower = 0, 
    eps.upper = 0.1, neighbor = TotalVarNeighborhood(), steps = 3)
Fixed part of the parameter at which estimate was produced:
size 
  25 
> plot(pIC(robest4))
> 
> 
> #############################
> ## 2. Poisson data
> #############################
> ## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
> x <- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
+        rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
+        rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))
> 
> ## ML-estimate
> MLest <- MLEstimator(x, PoisFamily())
> estimate(MLest)
[1] 3.871549
> confint(MLest)
A[n] asymptotic (CLT-based) confidence interval:
        2.5 %   97.5 %
[1,] 3.796033 3.947065
Type of estimator: Maximum likelihood estimate
samplesize:   2608
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = PoisFamily())
> 
> ## compute optimally robust estimator (unknown contamination)
> robest <- roptest(x, PoisFamily(), eps.upper = 0.1, steps = 3)
> estimate(robest)
  lambda 
3.908135 
> confint(robest, symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
          2.5 %   97.5 %
lambda 3.761616 4.054655
Type of estimator: 3-step estimate
samplesize:   2608
Call by which estimate was produced:
roptest(x = x, L2Fam = PoisFamily(), eps.upper = 0.1, steps = 3)
> plot(pIC(robest))
> qq2 <- qqplot(x, robest, cex.pch=1.5, exp.cex2.pch = -.25,
+               exp.fadcol.pch = .55, jit.fac=.9)
> str(qq2)
List of 2
 $ x: num [1:2608] -0.179 -0.176 -0.165 -0.161 -0.16 ...
 $ y: num [1:2608] -0.179 -0.179 -0.177 -0.17 -0.167 ...
>  
> ## total variation neighborhoods (unknown deviation)
> robest1 <- roptest(x, PoisFamily(), eps.upper = 0.05, 
+                   neighbor = TotalVarNeighborhood(), steps = 3)
> estimate(robest1)
  lambda 
3.900709 
> confint(robest1, symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %   97.5 %
lambda 3.75276 4.048659
Type of estimator: 3-step estimate
samplesize:   2608
Call by which estimate was produced:
roptest(x = x, L2Fam = PoisFamily(), eps.upper = 0.05, neighbor = TotalVarNeighborhood(), 
    steps = 3)
> plot(pIC(robest1))
> 
> 
> #############################
> ## 3. Normal (Gaussian) location and scale
> #############################
> ## 24 determinations of copper in wholemeal flour
> library(MASS)
> data(chem)
> plot(chem, main = "copper in wholemeal flour", pch = 20)
> 
> ## ML-estimate
> MLest <- MLEstimator(chem, NormLocationScaleFamily())
> estimate(MLest)
    mean       sd 
4.280417 5.185859 
> confint(MLest)
A[n] asymptotic (CLT-based) confidence interval:
        2.5 %   97.5 %
mean 2.205679 6.355154
sd   3.718798 6.652920
Type of estimator: Maximum likelihood estimate
samplesize:   24
Call by which estimate was produced:
MLEstimator(x = chem, ParamFamily = NormLocationScaleFamily())
> 
> ## compute optimally robust estimator (known contamination)
> ## takes some time -> you can use package RobLox for normal 
> ## location and scale which is optimized for speed
> robest <- roptest(chem, NormLocationScaleFamily(), eps = 0.05, steps = 3)
> estimate(robest)
    mean       sd 
3.143156 0.667100 
> confint(robest, symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %   97.5 %
mean 2.8118305 3.474482
sd   0.4223911 0.911809
Type of estimator: 3-step estimate
samplesize:   24
Call by which estimate was produced:
roptest(x = chem, L2Fam = NormLocationScaleFamily(), eps = 0.05, 
    steps = 3)
> plot(pIC(robest))
> ## plot of relative and absolute information; cf. Kohl (2005)
> infoPlot(pIC(robest))
> 
> qq3 <- qqplot(chem, robest, cex.pch=1.5, exp.cex2.pch = -.25,
+               exp.fadcol.pch = .55, withLab = TRUE, which.Order=1:4,
+               exp.cex2.lbl = .12,exp.fadcol.lbl = .45,
+               nosym.pCI = TRUE, adj.lbl=c(1.7,.2),
+               exact.pCI = FALSE, log ="xy")
> str(qq3)
List of 2
 $ x: num [1:24] 2.2 2.2 2.4 2.4 2.5 2.7 2.8 2.9 3.03 3.03 ...
 $ y: num [1:24] 1.78 2.12 2.3 2.44 2.55 ...
> 
> ## finite-sample correction
> if(require(RobLox)){
+     n <- length(chem)
+     r <- 0.05*sqrt(n)
+     r.fi <- finiteSampleCorrection(n = n, r = r)
+     fsCor <- r.fi/r
+     robest <- roptest(chem, NormLocationScaleFamily(), eps = 0.05, 
+                       fsCor = fsCor, steps = 3)
+     estimate(robest)
+ }
Loading required package: RobLox
     mean        sd 
3.1521868 0.6656978 
> 
> ## compute optimally robust estimator (unknown contamination)
> ## takes some time -> use package RobLox!
> robest1 <- roptest(chem, NormLocationScaleFamily(), eps.lower = 0.05, 
+                    eps.upper = 0.1, steps = 3)
> estimate(robest1)
     mean        sd 
3.1406123 0.6661885 
> confint(robest1, symmetricBias())
A[n] asymptotic (LAN-based), uniform (bias-aware)
 confidence interval:
for symmetric Bias
         2.5 %    97.5 %
mean 2.7838927 3.4973319
sd   0.4006326 0.9317444
Type of estimator: 3-step estimate
samplesize:   24
Call by which estimate was produced:
roptest(x = chem, L2Fam = NormLocationScaleFamily(), eps.lower = 0.05, 
    eps.upper = 0.1, steps = 3)
> plot(pIC(robest1))
> ## plot of relative and absolute information; cf. Kohl (2005)
> infoPlot(pIC(robest1))
> 
> 
> 
> ### * <FOOTER>
> ###
> cat("Time elapsed: ", proc.time() - get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  117.03 0.33 117.747 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
